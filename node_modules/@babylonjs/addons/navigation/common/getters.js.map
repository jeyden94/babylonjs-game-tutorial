{"version":3,"file":"getters.js","sourceRoot":"","sources":["../../../../../dev/addons/src/navigation/common/getters.ts"],"names":[],"mappings":"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","sourcesContent":["import { VertexBuffer } from \"core/Buffers/buffer\";\nimport { Matrix, Vector3 } from \"core/Maths/math.vector\";\nimport { Mesh } from \"core/Meshes/mesh\";\n\n/**\n *  Extracts positions and indices from an array of meshes.\n *  @param meshes The array of meshes from which to extract positions and indices.\n *  @returns A tuple containing a Float32Array of positions and a Uint32Array of\n */\nexport function GetPositionsAndIndices(\n    meshes: Mesh[],\n    options?: {\n        doNotReverseIndices?: boolean;\n    }\n): [positions: Float32Array, indices: Uint32Array] {\n    let offset = 0;\n    let index: number;\n    let tri: number;\n    let pt: number;\n    const positions: number[] = [];\n    const indices: number[] = [];\n\n    for (index = 0; index < meshes.length; index++) {\n        if (meshes[index]) {\n            const mesh = meshes[index];\n\n            const meshIndices = options?.doNotReverseIndices ? mesh.getIndices(false, true) : GetReversedIndices(mesh);\n            if (!meshIndices) {\n                continue;\n            }\n\n            const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n            if (!meshPositions) {\n                continue;\n            }\n\n            const worldMatrices: Matrix[] = [];\n            const worldMatrix = mesh.computeWorldMatrix(true);\n\n            if (mesh.hasThinInstances) {\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\n                for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n                    const tmpMatrix = new Matrix();\n                    const thinMatrix = thinMatrices[instanceIndex];\n                    thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n                    worldMatrices.push(tmpMatrix);\n                }\n            } else {\n                worldMatrices.push(worldMatrix);\n            }\n\n            const transformed = Vector3.Zero();\n            const position = Vector3.Zero();\n\n            for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n                const wm = worldMatrices[matrixIndex];\n                for (tri = 0; tri < meshIndices.length; tri++) {\n                    indices.push(meshIndices[tri] + offset);\n                }\n\n                for (pt = 0; pt < meshPositions.length; pt += 3) {\n                    Vector3.FromArrayToRef(meshPositions, pt, position);\n                    Vector3.TransformCoordinatesToRef(position, wm, transformed);\n                    positions.push(transformed.x, transformed.y, transformed.z);\n                }\n\n                offset += meshPositions.length / 3;\n            }\n        }\n    }\n    return [Float32Array.from(positions), Uint32Array.from(indices)];\n}\n\n/**\n * Reverses the order of vertices in each triangle (3 indices per face) to ensure\n * that the winding order is consistent with the Recast Navigation requirements.\n * This is necessary because Recast Navigation expects the indices to be in a specific winding order.\n * @param meshOrIndices The mesh from which to extract indices or the indices themselves.\n * @returns Array of indices with reversed winding order.\n */\nexport function GetReversedIndices(\n    meshOrIndices: Mesh | Uint32Array | number[]\n): Uint32Array<ArrayBufferLike> | number[] | Int32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | null {\n    const indices = meshOrIndices instanceof Mesh ? meshOrIndices.getIndices(false, true) : meshOrIndices;\n\n    if (indices) {\n        for (let i = 0; i < indices.length; i += 3) {\n            // Swap the second and third index to reverse the winding order\n            [indices[i + 1], indices[i + 2]] = [indices[i + 2], indices[i + 1]];\n        }\n    }\n\n    return indices;\n}\n"]}