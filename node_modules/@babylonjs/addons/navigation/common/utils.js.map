{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../dev/addons/src/navigation/common/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IVector3Like } from \"core/Maths/math.like\";\nimport { Vector3 } from \"core/Maths/math.vector\";\n\n/**\n * Utility function based on Chaikin's alogrithm for navigation path smoothing and segment generation.\n * @param points Array of points to be smoothed, where each point is an object with x, y, and z properties.\n * @param iterations Number of smoothing iterations to apply. Default 1.\n * @returns A new array of smoothed points after applying the Chaikin's algorithm.\n */\nexport function GetChaikinSmoothPath(points: IVector3Like[], iterations = 1) {\n    for (let i = 0; i < iterations; i++) {\n        const smoothed = [];\n        for (let j = 0; j < points.length - 1; j++) {\n            const p0 = points[j];\n            const p1 = points[j + 1];\n\n            smoothed.push({\n                x: 0.75 * p0.x + 0.25 * p1.x,\n                y: 0.75 * p0.y + 0.25 * p1.y,\n                z: 0.75 * p0.z + 0.25 * p1.z,\n            });\n\n            smoothed.push({\n                x: 0.25 * p0.x + 0.75 * p1.x,\n                y: 0.25 * p0.y + 0.75 * p1.y,\n                z: 0.25 * p0.z + 0.75 * p1.z,\n            });\n        }\n\n        if (points[0].x === points[points.length - 1].x && points[0].y === points[points.length - 1].y && points[0].z === points[points.length - 1].z) {\n            smoothed.push(smoothed[0]);\n        }\n\n        points = smoothed;\n    }\n    return points;\n}\n\n/**\n *  Generates a series of points that create an L-shaped path between each pair of points in the input navigation segment.\n *  The path consists of a horizontal segment followed by a vertical segment, or vice versa,\n *  depending on the relative distances between the x and z coordinates of the points.\n * @param navSegment An array of Vector3 points representing the navigation segment.\n * @returns An array of Vector3 points representing the L-shaped path.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function GetLShapedPath(navSegment: Vector3[]) {\n    const points = [];\n    for (let j = 0; j < navSegment.length - 1; j++) {\n        const p0 = navSegment[j];\n        const p1 = navSegment[j + 1];\n        const p01 = getLShapedPoint(p0, p1);\n        points.push(p0, new Vector3(p01.x, p1.y, p01.z), p1);\n    }\n    return points;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getLShapedPoint(pointA: IVector3Like, pointB: IVector3Like) {\n    const { x: x1, z: y1 } = pointA;\n    const { x: x2, z: y2 } = pointB;\n\n    let pointC;\n\n    // Determine turn direction automatically based on the offset\n    if (Math.abs(x2 - x1) >= Math.abs(y2 - y1)) {\n        // Horizontal-then-vertical turn\n        pointC = { x: x2, z: y1 };\n    } else {\n        // Vertical-then-horizontal turn\n        pointC = { x: x1, z: y2 };\n    }\n\n    return pointC;\n}\n"]}