{"version":3,"file":"smooth-path.js","sourceRoot":"","sources":["../../../../../dev/addons/src/navigation/common/smooth-path.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NavMeshQuery, NavMesh, QueryFilter } from \"@recast-navigation/core\";\n\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport { Vector3 } from \"core/Maths/math.vector\";\n\nimport { ConvertNavPathPoints } from \"./convert\";\nimport type { RecastInjection, SteerTargetResult } from \"../types\";\nimport { ComputePathError, type ComputePathResult } from \"../types\";\nimport { GetRecast } from \"../factory/common\";\n\nconst _DELTA = new Vector3();\nconst _MOVE_TARGET = new Vector3();\n\n/**\n * Compute a smooth navigation path from start to end. Returns an empty array if no path can be computed\n * @param navMesh the navigation mesh to use\n * @param navmeshQuery the navigation mesh query to use\n * @param start world position\n * @param end world position\n * @param options options object\n * @returns array containing world position composing the path\n */\nexport function ComputeSmoothPath(\n    navMesh: NavMesh,\n    navmeshQuery: NavMeshQuery,\n    start: IVector3Like,\n    end: IVector3Like,\n    options?: {\n        filter?: QueryFilter;\n        halfExtents?: IVector3Like;\n\n        /**\n         * @default 256\n         */\n        maxPathPolys?: number;\n\n        /**\n         * @default 2048\n         */\n        maxSmoothPathPoints?: number;\n\n        /**\n         * @default 0.5\n         */\n        stepSize?: number;\n\n        /**\n         * @default 0.01\n         */\n        slop?: number;\n    }\n): Vector3[] {\n    return ConvertNavPathPoints(ComputeSmoothPathImpl(navMesh, navmeshQuery, start, end, options));\n}\n\nfunction ComputeSmoothPathImpl(\n    navMesh: NavMesh,\n    navMeshQuery: NavMeshQuery,\n    start: IVector3Like,\n    end: IVector3Like,\n    options?: {\n        filter?: QueryFilter;\n        halfExtents?: IVector3Like;\n        maxPathPolys?: number;\n        maxSmoothPathPoints?: number;\n        stepSize?: number;\n        slop?: number;\n    }\n): ComputePathResult {\n    const recast = GetRecast();\n    const filter = options?.filter ?? navMeshQuery.defaultFilter;\n    const halfExtents = options?.halfExtents ?? navMeshQuery.defaultQueryHalfExtents;\n    const maxSmoothPathPoints = options?.maxSmoothPathPoints ?? 2048;\n    const maxPathPolys = options?.maxPathPolys ?? 256;\n    const stepSize = options?.stepSize ?? 0.5;\n    const slop = options?.slop ?? 0.01;\n\n    // find nearest polygons for start and end positions\n    const startNearestPolyResult = navMeshQuery.findNearestPoly(start, {\n        filter,\n        halfExtents,\n    });\n\n    if (!startNearestPolyResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.START_NEAREST_POLY_FAILED,\n                status: startNearestPolyResult.status,\n            },\n            path: [],\n        };\n    }\n\n    const endNearestPolyResult = navMeshQuery.findNearestPoly(end, {\n        filter,\n        halfExtents,\n    });\n\n    if (!endNearestPolyResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.END_NEAREST_POLY_FAILED,\n                status: endNearestPolyResult.status,\n            },\n            path: [],\n        };\n    }\n\n    const startRef = startNearestPolyResult.nearestRef;\n    const endRef = endNearestPolyResult.nearestRef;\n\n    // find polygon path\n    const findPathResult = navMeshQuery.findPath(startRef, endRef, start, end, {\n        filter,\n        maxPathPolys,\n    });\n\n    if (!findPathResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.FIND_PATH_FAILED,\n                status: findPathResult.status,\n            },\n            path: [],\n        };\n    }\n\n    if (findPathResult.polys.size <= 0) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.NO_POLYGON_PATH_FOUND,\n            },\n            path: [],\n        };\n    }\n\n    const lastPoly = findPathResult.polys.get(findPathResult.polys.size - 1);\n\n    let closestEnd = end;\n\n    if (lastPoly !== endRef) {\n        const lastPolyClosestPointResult = navMeshQuery.closestPointOnPoly(lastPoly, end);\n\n        if (!lastPolyClosestPointResult.success) {\n            return {\n                success: false,\n                error: {\n                    type: ComputePathError.NO_CLOSEST_POINT_ON_LAST_POLYGON_FOUND,\n                    status: lastPolyClosestPointResult.status,\n                },\n                path: [],\n            };\n        }\n\n        closestEnd = lastPolyClosestPointResult.closestPoint;\n    }\n\n    // Iterate over the path to find a smooth path on the detail mesh\n    const iterPos = new Vector3(start.x, start.y, start.z);\n    const targetPos = new Vector3(closestEnd.x, closestEnd.y, closestEnd.z);\n\n    const polys = Array.from(findPathResult.polys.getHeapView());\n    const smoothPath: Vector3[] = [];\n\n    smoothPath.push(iterPos.clone());\n\n    while (polys.length > 0 && smoothPath.length < maxSmoothPathPoints) {\n        // Find location to steer towards\n        const steerTarget = getSteerTarget(navMeshQuery, iterPos, targetPos, slop, polys, recast);\n\n        if (!steerTarget.success) {\n            break;\n        }\n\n        const isEndOfPath = steerTarget.steerPosFlag & recast.Detour.DT_STRAIGHTPATH_END;\n        const isOffMeshConnection = steerTarget.steerPosFlag & recast.Detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION;\n\n        // Find movement delta.\n        const steerPos = steerTarget.steerPos;\n        const delta = _DELTA.copyFrom(steerPos).subtract(iterPos);\n        let len = Math.sqrt(delta.dot(delta));\n\n        // If the steer target is the end of the path or an off-mesh connection, do not move past the location.\n        if ((isEndOfPath || isOffMeshConnection) && len < stepSize) {\n            len = 1;\n        } else {\n            len = stepSize / len;\n        }\n\n        const moveTarget = _MOVE_TARGET.copyFrom(iterPos).addInPlace(delta.scale(len));\n\n        // Move\n        const moveAlongSurface = navMeshQuery.moveAlongSurface(polys[0], iterPos, moveTarget, { filter, maxVisitedSize: 16 });\n\n        if (!moveAlongSurface.success) {\n            break;\n        }\n\n        const result = moveAlongSurface.resultPosition;\n\n        fixupCorridor(polys, maxPathPolys, moveAlongSurface.visited);\n        fixupShortcuts(polys, navMesh, recast);\n\n        const polyHeightResult = navMeshQuery.getPolyHeight(polys[0], result);\n\n        if (polyHeightResult.success) {\n            result.y = polyHeightResult.height;\n        }\n\n        iterPos.copyFromFloats(result.x, result.y, result.z);\n\n        // Handle end of path and off-mesh links when close enough\n        if (isEndOfPath && inRange(iterPos, steerTarget.steerPos, slop, 1.0)) {\n            // Reached end of path\n            iterPos.copyFrom(targetPos);\n\n            if (smoothPath.length < maxSmoothPathPoints) {\n                smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n            }\n\n            break;\n        } else if (isOffMeshConnection && inRange(iterPos, steerTarget.steerPos, slop, 1.0)) {\n            // Reached off-mesh connection.\n\n            // Advance the path up to and over the off-mesh connection.\n            const offMeshConRef = steerTarget.steerPosRef;\n\n            // Advance the path up to and over the off-mesh connection.\n            let prevPolyRef = 0;\n            let polyRef = polys[0];\n            let npos = 0;\n            while (npos < polys.length && polyRef !== offMeshConRef) {\n                prevPolyRef = polyRef;\n                polyRef = polys[npos];\n                npos++;\n            }\n\n            for (let i = npos; i < polys.length; i++) {\n                polys[i - npos] = polys[i];\n            }\n            polys.splice(npos, polys.length - npos);\n\n            // Handle the connection\n            const offMeshConnectionPolyEndPoints = navMesh.getOffMeshConnectionPolyEndPoints(prevPolyRef, polyRef);\n\n            if (offMeshConnectionPolyEndPoints.success) {\n                if (smoothPath.length < maxSmoothPathPoints) {\n                    smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n\n                    // Hack to make the dotted path not visible during off-mesh connection.\n                    if (smoothPath.length & 1) {\n                        smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n                    }\n\n                    // Move position at the other side of the off-mesh link.\n                    iterPos.copyFromFloats(offMeshConnectionPolyEndPoints.end.x, offMeshConnectionPolyEndPoints.end.y, offMeshConnectionPolyEndPoints.end.z);\n\n                    const endPositionPolyHeight = navMeshQuery.getPolyHeight(polys[0], iterPos);\n\n                    if (endPositionPolyHeight.success) {\n                        iterPos.y = endPositionPolyHeight.height;\n                    }\n                }\n            }\n        }\n\n        // Store results.\n        if (smoothPath.length < maxSmoothPathPoints) {\n            smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n        }\n    }\n\n    return {\n        success: true,\n        path: smoothPath,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getSteerTarget(navMeshQuery: NavMeshQuery, start: Vector3, end: Vector3, minTargetDist: number, pathPolys: number[], recast: RecastInjection): SteerTargetResult {\n    const maxSteerPoints = 3;\n    const straightPath = navMeshQuery.findStraightPath(start, end, pathPolys, {\n        maxStraightPathPoints: maxSteerPoints,\n    });\n\n    if (!straightPath.success) {\n        return {\n            success: false,\n        };\n    }\n\n    const outPoints: Vector3[] = [];\n    for (let i = 0; i < straightPath.straightPathCount; i++) {\n        const point = new Vector3(straightPath.straightPath.get(i * 3), straightPath.straightPath.get(i * 3 + 1), straightPath.straightPath.get(i * 3 + 2));\n\n        outPoints.push(point);\n    }\n\n    // Find vertex far enough to steer to\n    let ns = 0;\n    while (ns < outPoints.length) {\n        // Stop at Off-Mesh link or when point is further than slop away\n        if (straightPath.straightPathFlags.get(ns) & recast.Detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION) {\n            break;\n        }\n\n        const posA = outPoints[ns];\n        const posB = start;\n\n        if (!inRange(posA, posB, minTargetDist, 1000.0)) {\n            break;\n        }\n\n        ns++;\n    }\n\n    // Failed to find good point to steer to\n    if (ns >= straightPath.straightPathCount) {\n        return {\n            success: false,\n        };\n    }\n\n    const steerPos = outPoints[ns];\n    const steerPosFlag = straightPath.straightPathFlags.get(ns);\n    const steerPosRef = straightPath.straightPathRefs.get(ns);\n\n    return {\n        success: true,\n        steerPos,\n        steerPosFlag,\n        steerPosRef,\n        points: outPoints,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction inRange(a: Vector3, b: Vector3, r: number, h: number) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const dz = b.z - a.z;\n    return dx * dx + dz * dz < r && Math.abs(dy) < h;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction fixupCorridor(pathPolys: number[], maxPath: number, visitedPolyRefs: number[]) {\n    let furthestPath = -1;\n    let furthestVisited = -1;\n\n    // Find furthest common polygon.\n    for (let i = pathPolys.length - 1; i >= 0; i--) {\n        let found = false;\n        for (let j = visitedPolyRefs.length - 1; j >= 0; j--) {\n            if (pathPolys[i] === visitedPolyRefs[j]) {\n                furthestPath = i;\n                furthestVisited = j;\n                found = true;\n            }\n        }\n        if (found) {\n            break;\n        }\n    }\n\n    // If no intersection found just return current path.\n    if (furthestPath === -1 || furthestVisited === -1) {\n        return pathPolys;\n    }\n\n    // Concatenate paths.\n\n    // Adjust beginning of the buffer to include the visited.\n    const req = visitedPolyRefs.length - furthestVisited;\n    const orig = Math.min(furthestPath + 1, pathPolys.length);\n\n    let size = Math.max(0, pathPolys.length - orig);\n\n    if (req + size > maxPath) {\n        size = maxPath - req;\n    }\n    if (size) {\n        pathPolys.splice(req, size, ...pathPolys.slice(orig, orig + size));\n    }\n\n    // Store visited\n    for (let i = 0; i < req; i++) {\n        pathPolys[i] = visitedPolyRefs[visitedPolyRefs.length - (1 + i)];\n    }\n\n    return pathPolys;\n}\n\n/**\n * This function checks if the path has a small U-turn, that is,\n * a polygon further in the path is adjacent to the first polygon\n * in the path. If that happens, a shortcut is taken.\n * This can happen if the target (T) location is at tile boundary,\n * and we're (S) approaching it parallel to the tile edge.\n * The choice at the vertex can be arbitrary,\n *  +---+---+\n *  |:::|:::|\n *  +-S-+-T-+\n *  |:::|   | -- the step can end up in here, resulting U-turn path.\n *  +---+---+\n * @param pathPolys The path polygons to check for U-turns.\n * @param navMesh The navigation mesh used to check adjacency.\n * @param recast The recast injection to use.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction fixupShortcuts(pathPolys: number[], navMesh: NavMesh, recast: RecastInjection) {\n    if (pathPolys.length < 3) {\n        return;\n    }\n\n    // Get connected polygons\n    const maxNeis = 16;\n    let nneis = 0;\n    const neis: number[] = [];\n\n    const tileAndPoly = navMesh.getTileAndPolyByRef(pathPolys[0]);\n\n    if (!tileAndPoly.success) {\n        return;\n    }\n\n    const poly = tileAndPoly.poly;\n    const tile = tileAndPoly.tile;\n    for (let k = poly.firstLink(); k !== recast.Detour.DT_NULL_LINK; k = tile.links(k).next()) {\n        const link = tile.links(k);\n\n        if (link.ref() !== 0) {\n            if (nneis < maxNeis) {\n                neis.push(link.ref());\n                nneis++;\n            }\n        }\n    }\n\n    // If any of the neighbour polygons is within the next few polygons\n    // in the path, short cut to that polygon directly.\n    const maxLookAhead = 6;\n    let cut = 0;\n    for (let i = Math.min(maxLookAhead, pathPolys.length) - 1; i > 1 && cut === 0; i--) {\n        for (let j = 0; j < nneis; j++) {\n            if (pathPolys[i] === neis[j]) {\n                cut = i;\n                break;\n            }\n        }\n    }\n\n    if (cut > 1) {\n        pathPolys.splice(1, cut - 1);\n    }\n}\n"]}