import type { Crowd } from "@recast-navigation/core";
import type { IVector3Like } from "@babylonjs/core/Maths/math.like.js";
import type { TransformNode } from "@babylonjs/core/Meshes/transformNode.js";
import type { ICrowd } from "@babylonjs/core/Navigation/INavigationEngine.js";
import { Vector3 } from "@babylonjs/core/Maths/math.vector.js";
import { Observable } from "@babylonjs/core/Misc/observable.js";
import type { Scene } from "@babylonjs/core/scene.js";
import type { RecastNavigationJSPluginV2 } from "./RecastNavigationJSPlugin.js";
import type { IAgentParametersV2 } from "../types.js";
/**
 * Recast Detour crowd implementation
 * This class provides methods to manage a crowd of agents, allowing them to navigate a navigation mesh.
 * It supports adding agents, updating their parameters, moving them to destinations, and checking their states.
 * The crowd is updated in the scene's animation loop, and it notifies observers when agents reach their destinations.
 */
export declare class RecastJSCrowd implements ICrowd {
    /**
     * Recast plugin
     */
    get navigationPlugin(): RecastNavigationJSPluginV2;
    /**
     * Link to the detour crowd
     */
    get recastCrowd(): Crowd;
    /**
     * One transform per agent
     */
    get transforms(): TransformNode[];
    /**
     * All agents created
     */
    get agents(): readonly number[];
    /**
     * Agents reach radius
     */
    get reachRadii(): readonly number[];
    private _navigationPlugin;
    private _recastCrowd;
    private _transforms;
    private _agents;
    private _reachRadii;
    /**
     * true when a destination is active for an agent and notifier hasn't been notified of reach
     */
    private _agentDestinationArmed;
    /**
     * agent current target
     */
    private _agentDestination;
    /**
     * Link to the scene is kept to unregister the crowd from the scene
     */
    private _scene;
    private _engine;
    /**
     * Observer for crowd updates
     */
    private _onBeforeAnimationsObserver;
    /**
     * Fires each time an agent is in reach radius of its destination
     */
    onReachTargetObservable: Observable<{
        /**
         *
         */
        agentIndex: number;
        /**
         *
         */
        destination: Vector3;
    }>;
    /**
     * Constructor
     * @param plugin recastJS plugin
     * @param maxAgents the maximum agent count in the crowd
     * @param maxAgentRadius the maximum radius an agent can have
     * @param scene to attach the crowd to
     * @returns the crowd you can add agents to
     */
    constructor(plugin: RecastNavigationJSPluginV2, maxAgents: number, maxAgentRadius: number, scene: Scene);
    /**
     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.
     * You can attach anything to that node. The node position is updated in the scene update tick.
     * @param pos world position that will be constrained by the navigation mesh
     * @param parameters agent parameters
     * @param transform hooked to the agent that will be update by the scene
     * @returns agent index
     */
    addAgent(pos: IVector3Like, parameters: IAgentParametersV2, transform: TransformNode): number;
    /**
     * Returns the agent position in world space
     * @param index agent index returned by addAgent
     * @returns world space position
     */
    getAgentPosition(index: number): Vector3;
    /**
     * Returns the agent position result in world space
     * @param index agent index returned by addAgent
     * @param result output world space position
     */
    getAgentPositionToRef(index: number, result: Vector3): void;
    /**
     * Returns the agent velocity in world space
     * @param index agent index returned by addAgent
     * @returns world space velocity
     */
    getAgentVelocity(index: number): Vector3;
    /**
     * Returns the agent velocity result in world space
     * @param index agent index returned by addAgent
     * @param result output world space velocity
     */
    getAgentVelocityToRef(index: number, result: Vector3): void;
    /**
     * Returns the agent next target point on the path
     * @param index agent index returned by addAgent
     * @returns world space position
     */
    getAgentNextTargetPath(index: number): Vector3;
    /**
     * Returns the agent next target point on the path
     * @param index agent index returned by addAgent
     * @param result output world space position
     */
    getAgentNextTargetPathToRef(index: number, result: Vector3): void;
    /**
     * Gets the agent state
     * @param index agent index returned by addAgent
     * @returns agent state, 0 = DT_CROWDAGENT_STATE_INVALID, 1 = DT_CROWDAGENT_STATE_WALKING, 2 = DT_CROWDAGENT_STATE_OFFMESH
     */
    getAgentState(index: number): number;
    /**
     * returns true if the agent in over an off mesh link connection
     * @param index agent index returned by addAgent
     * @returns true if over an off mesh link connection
     */
    overOffmeshConnection(index: number): boolean;
    /**
     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh
     * @param index agent index returned by addAgent
     * @param destination targeted world position
     */
    agentGoto(index: number, destination: IVector3Like): void;
    /**
     * Teleport the agent to a new position
     * @param index agent index returned by addAgent
     * @param destination targeted world position
     */
    agentTeleport(index: number, destination: IVector3Like): void;
    /**
     * Update agent parameters
     * @param index agent index returned by addAgent
     * @param parameters agent parameters
     */
    updateAgentParameters(index: number, parameters: IAgentParametersV2): void;
    /**
     * remove a particular agent previously created
     * @param index agent index returned by addAgent
     */
    removeAgent(index: number): void;
    /**
     * get the list of all agents attached to this crowd
     * @returns list of agent indices
     */
    getAgents(): number[];
    /**
     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function
     * @param deltaTime in seconds
     */
    update(deltaTime: number): void;
    /**
     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
     * The queries will try to find a solution within those bounds
     * default is (1,1,1)
     * @param extent x,y,z value that define the extent around the queries point of reference
     */
    setDefaultQueryExtent(extent: IVector3Like): void;
    /**
     * Get the Bounding box extent specified by setDefaultQueryExtent
     * @returns the box extent values
     */
    getDefaultQueryExtent(): Vector3;
    /**
     * Get the Bounding box extent result specified by setDefaultQueryExtent
     * @param result output the box extent values
     */
    getDefaultQueryExtentToRef(result: Vector3): void;
    /**
     * Get the next corner points composing the path (max 4 points)
     * @param index agent index returned by addAgent
     * @returns array containing world position composing the path
     */
    getCorners(index: number): Vector3[];
    /**
     * Release all resources
     */
    dispose(): void;
}
