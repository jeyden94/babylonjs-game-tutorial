{"version":3,"file":"RecastNavigationJSPlugin.js","sourceRoot":"","sources":["../../../../../dev/addons/src/navigation/plugin/RecastNavigationJSPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TileCacheMeshProcess, NavMesh, QueryFilter, TileCache, NavMeshQuery } from \"@recast-navigation/core\";\n\nimport type { ICrowd, INavigationEnginePlugin, IObstacle } from \"core/Navigation/INavigationEngine\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { Mesh } from \"core/Meshes/mesh\";\nimport type { Scene } from \"core/scene\";\nimport { TmpVectors, Vector3 } from \"core/Maths/math\";\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport type { Nullable } from \"core/types\";\n\nimport type { CreateNavMeshResult, GeneratorIntermediates, INavMeshParametersV2, RecastInjection } from \"../types\";\nimport { RecastJSCrowd } from \"./RecastJSCrowd\";\nimport { ConvertNavPathPoints } from \"../common/convert\";\nimport { ComputeSmoothPath } from \"../common/smooth-path\";\nimport { CreateDebugNavMesh } from \"../debug/simple-debug\";\nimport { GetRecast } from \"../factory/common\";\nimport { InjectGenerators } from \"../generator/injection\";\nimport { DefaultMaxObstacles } from \"../common/config\";\nimport { CreateDefaultTileCacheMeshProcess, WaitForFullTileCacheUpdate } from \"../common/tile-cache\";\n\n/**\n * Navigation plugin for Babylon.js. It is a simple wrapper around the recast-navigation-js library. Not all features are implemented.\n * @remarks This plugin provides navigation mesh generation and pathfinding capabilities using the recast-navigation-js library\n * @remarks It supports both single-threaded and multi-threaded generation of navigation meshes.\n * @remarks The plugin can be used to create navigation meshes from meshes in a scene, compute paths, and manage crowd agents, etc.\n * @remarks It also provides methods for creating obstacles and querying the navigation mesh.\n * @see https://github.com/isaac-mason/recast-navigation-js\n */\nexport class RecastNavigationJSPluginV2 implements INavigationEnginePlugin {\n    /**\n     *  Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     */\n    createNavMeshImpl: (meshes: Array<Mesh>, parameters: INavMeshParametersV2) => CreateNavMeshResult;\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     */\n    createNavMeshAsyncImpl: (meshes: Array<Mesh>, parameters: INavMeshParametersV2) => Promise<CreateNavMeshResult>;\n\n    /**\n     * recast-navigation-js injection\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public bjsRECAST: RecastInjection;\n\n    /**\n     * plugin name\n     */\n    public name: string = \"RecastNavigationJSPlugin\";\n\n    /**\n     * the navmesh created\n     */\n    public navMesh?: NavMesh;\n\n    /**\n     * The navmesh query created from the navmesh\n     * @remarks This is used to query the navmesh for pathfinding and other navigation tasks\n     */\n    public get navMeshQuery(): NavMeshQuery {\n        return this._navMeshQuery;\n    }\n\n    private _navMeshQuery!: NavMeshQuery;\n\n    /**\n     * Intermediates generated during the navmesh creation\n     * @remarks This is used for debugging and visualization purposes.\n     * @remarks You have access to vertices, indices and vertex colors to visusalize the navmesh creation process.\n     * @remarks This is only available if the `keepIntermediates` parameter is set\n     * @remarks to true during navmesh generation.\n     */\n    private _intermediates?: GeneratorIntermediates;\n\n    /**\n     * Gets the intermediates generated during the navmesh creation\n     * @returns The generator intermediates, or undefined if not available\n     */\n    public get intermediates(): GeneratorIntermediates | undefined {\n        return this._intermediates;\n    }\n\n    /**\n     * Tile cache used for tiled navigation meshes\n     * @remarks This is used to store and manage tiles of the navigation mesh for efficient path and when obstacles are used.\n     */\n    private _tileCache?: TileCache;\n\n    /**\n     * Gets the tile cache used for tiled navigation meshes\n     * @returns The tile cache instance, or undefined if not available\n     */\n    public get tileCache(): TileCache | undefined {\n        return this._tileCache;\n    }\n\n    // Crowd specific properties\n    private _maximumSubStepCount: number = 10;\n    private _timeStep: number = 1 / 60;\n    private _timeFactor: number = 1;\n\n    private _crowd?: ICrowd;\n\n    /**\n     * Creates a RecastNavigationJSPluginV2 instance\n     * @param recastInjection The recast-navigation-js injection containing core and generators\n     */\n    public constructor(recastInjection?: RecastInjection) {\n        if (!recastInjection) {\n            recastInjection = GetRecast();\n            InjectGenerators(this);\n        }\n\n        this.bjsRECAST = recastInjection;\n\n        if (!this.isSupported()) {\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n            return;\n        }\n        this.setTimeStep();\n    }\n\n    /**\n     * Set the time step of the navigation tick update.\n     * Default is 1/60.\n     * A value of 0 will disable fixed time update\n     * @param newTimeStep the new timestep to apply to this world.\n     */\n    public setTimeStep(newTimeStep: number = 1 / 60): void {\n        this._timeStep = newTimeStep;\n    }\n\n    /**\n     * Get the time step of the navigation tick update.\n     * @returns the current time step\n     */\n    public getTimeStep(): number {\n        return this._timeStep;\n    }\n\n    /**\n     * If delta time in navigation tick update is greater than the time step\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\n     * they will be discarded.\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\n     * @param newStepCount the maximum number of iterations\n     */\n    public setMaximumSubStepCount(newStepCount: number = 10): void {\n        this._maximumSubStepCount = newStepCount;\n    }\n\n    /**\n     * Get the maximum number of iterations per navigation tick update\n     * @returns the maximum number of iterations\n     */\n    public getMaximumSubStepCount(): number {\n        return this._maximumSubStepCount;\n    }\n\n    /**\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n     * @param value the time factor applied at update\n     */\n    public set timeFactor(value: number) {\n        this._timeFactor = Math.max(value, 0);\n    }\n\n    /**\n     * Get the time factor used for crowd agent update\n     * @returns the time factor\n     */\n    public get timeFactor(): number {\n        return this._timeFactor;\n    }\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     * @throws Error if the function is not injected yet or if the navmesh is not created\n     */\n    public createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParametersV2): CreateNavMeshResult {\n        if (!this.createNavMeshImpl) {\n            throw new Error(\"Function not injected yet. Use the factory to create the plugin.\");\n        }\n\n        this._preprocessParameters(parameters);\n\n        const result = this.createNavMeshImpl(meshes, parameters);\n        return this._processNavMeshResult(result);\n    }\n\n    /**\n     * Creates a navigation mesh asynchronously - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     * @throws Error if the function is not injected yet or if the navmesh is not created\n     */\n    public async createNavMeshAsync(meshes: Array<Mesh>, parameters: INavMeshParametersV2): Promise<CreateNavMeshResult> {\n        if (!this.createNavMeshAsyncImpl) {\n            throw new Error(\"Function not injected yet. Use the factory to create the plugin.\");\n        }\n\n        this._preprocessParameters(parameters);\n\n        const result = await this.createNavMeshAsyncImpl(meshes, parameters);\n        return this._processNavMeshResult(result);\n    }\n\n    /**\n     * Create a navigation mesh debug mesh\n     * @param scene is where the mesh will be added\n     * @returns debug display mesh\n     */\n    public createDebugNavMesh(scene: Scene): Mesh {\n        if (!this.navMesh) {\n            throw new Error(\"There is no navMesh generated.\");\n        }\n\n        if (this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return CreateDebugNavMesh(this.navMesh, scene);\n    }\n\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    public getClosestPoint(\n        position: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.findClosestPoint(position, options);\n        const pr = new Vector3(ret.point.x, ret.point.y, ret.point.z);\n        return pr;\n    }\n\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    public getClosestPointToRef(\n        position: IVector3Like,\n        result: Vector3,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): void {\n        const ret = this._navMeshQuery.findClosestPoint(position, options);\n        result.set(ret.point.x, ret.point.y, ret.point.z);\n    }\n\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    public getRandomPointAround(\n        position: IVector3Like,\n        maxRadius: number,\n        options?: {\n            startRef?: number;\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.findRandomPointAroundCircle(position, maxRadius, options);\n        const pr = new Vector3(ret.randomPoint.x, ret.randomPoint.y, ret.randomPoint.z);\n        return pr;\n    }\n\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    public getRandomPointAroundToRef(\n        position: IVector3Like,\n        maxRadius: number,\n        result: Vector3,\n        options?: {\n            startRef?: number;\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): void {\n        const ret = this._navMeshQuery.findRandomPointAroundCircle(position, maxRadius, options);\n        result.set(ret.randomPoint.x, ret.randomPoint.y, ret.randomPoint.z);\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position position to start from\n     * @param destination position to go to\n     * @param startRef the reference id of the start polygon\n     * @param options options for the function\n     * @returns the resulting point along the navmesh\n     */\n    public moveAlong(\n        position: IVector3Like,\n        destination: IVector3Like,\n        startRef = 0,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * The maximum number of polygons the output visited array can hold.\n             */\n            maxVisitedSize?: number;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.moveAlongSurface(startRef, position, destination, options);\n        const pr = new Vector3(ret.resultPosition.x, ret.resultPosition.y, ret.resultPosition.z);\n        return pr;\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position world position\n     * @param destination world position\n     * @param result output the resulting point along the navmesh\n     * @param startRef the reference id of the start polygon.\n     * @param options options for the function\n     */\n    public moveAlongToRef(\n        position: IVector3Like,\n        destination: IVector3Like,\n        result: Vector3,\n        startRef = 0,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            maxVisitedSize?: number;\n        }\n    ): void {\n        const ret = this._navMeshQuery.moveAlongSurface(startRef, position, destination, options);\n        result.set(ret.resultPosition.x, ret.resultPosition.y, ret.resultPosition.z);\n    }\n\n    /**\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n     * Path is straight.\n     * @param start world position\n     * @param end world position\n     * @param options options for the function\n     * @returns array containing world position composing the path\n     */\n    public computePath(\n        start: IVector3Like,\n        end: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            maxPathPolys?: number;\n            maxStraightPathPoints?: number;\n        }\n    ): Vector3[] {\n        return ConvertNavPathPoints(this._navMeshQuery.computePath(start, end, options));\n    }\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param start the start position of the navmesh\n     * @param end the end position of the navmesh\n     * @param options options to configure the path computation\n     * @returns array containing world position composing the path\n     */\n    public computePathSmooth(\n        start: Vector3,\n        end: Vector3,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            maxPathPolys?: number;\n            maxSmoothPathPoints?: number;\n            stepSize?: number;\n            slop?: number;\n        }\n    ): Vector3[] {\n        if (!this.navMesh) {\n            Logger.Error(\"No navmesh available. Cannot compute smooth path.\");\n            return [];\n        }\n        return ComputeSmoothPath(this.navMesh, this._navMeshQuery, start, end, options);\n    }\n\n    /**\n     * Create a new Crowd so you can add agents\n     * @param maxAgents the maximum agent count in the crowd\n     * @param maxAgentRadius the maximum radius an agent can have\n     * @param scene to attach the crowd to\n     * @returns the crowd you can add agents to\n     */\n    public createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n        this._crowd = crowd;\n        return crowd;\n    }\n\n    /**\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n     * The queries will try to find a solution within those bounds\n     * default is (1,1,1)\n     * @param extent x,y,z value that define the extent around the queries point of reference\n     */\n    public setDefaultQueryExtent(extent: IVector3Like): void {\n        this._navMeshQuery.defaultQueryHalfExtents = extent;\n    }\n\n    /**\n     * Get the Bounding box extent specified by setDefaultQueryExtent\n     * @returns the box extent values\n     */\n    public getDefaultQueryExtent(): Vector3 {\n        return new Vector3(this._navMeshQuery.defaultQueryHalfExtents.x, this._navMeshQuery.defaultQueryHalfExtents.y, this._navMeshQuery.defaultQueryHalfExtents.z);\n    }\n\n    /**\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\n     * @param result output the box extent values\n     */\n    public getDefaultQueryExtentToRef(result: Vector3): void {\n        result.set(this._navMeshQuery.defaultQueryHalfExtents.x, this._navMeshQuery.defaultQueryHalfExtents.y, this._navMeshQuery.defaultQueryHalfExtents.z);\n    }\n\n    /**\n     * build the navmesh from a previously saved state using getNavmeshData\n     * @param data the Uint8Array returned by getNavmeshData\n     */\n    public buildFromNavmeshData(data: Uint8Array): void {\n        const result = this.bjsRECAST.importNavMesh(data);\n        this.navMesh = result.navMesh;\n        this._navMeshQuery = new this.bjsRECAST.NavMeshQuery(this.navMesh);\n    }\n\n    /**\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n     * @returns data the Uint8Array that can be saved and reused\n     */\n    public getNavmeshData(): Uint8Array {\n        if (!this.navMesh) {\n            throw new Error(\"There is no NavMesh generated.\");\n        }\n        return this.bjsRECAST.exportNavMesh(this.navMesh);\n    }\n\n    /**\n     * build the tile cache from a previously saved state using getTileCacheData\n     * @param tileCacheData the data returned by getTileCacheData\n     * @param tileCacheMeshProcess optional process to apply to each tile created\n     */\n    public buildFromTileCacheData(tileCacheData: Uint8Array, tileCacheMeshProcess?: TileCacheMeshProcess): void {\n        const result = this.bjsRECAST.importTileCache(tileCacheData, tileCacheMeshProcess ?? CreateDefaultTileCacheMeshProcess([]));\n        this.navMesh = result.navMesh;\n        this._tileCache = result.tileCache;\n        this._navMeshQuery = new this.bjsRECAST.NavMeshQuery(this.navMesh);\n    }\n\n    /**\n     * returns the tile cache data that can be used later. The tile cache must be built before retrieving the data\n     * @returns the tile cache data that can be used later. The tile cache must be built before retrieving the data\n     * @throws Error if there is no TileCache generated\n     * @remarks The returned data can be used to rebuild the tile cache later using buildFromTileCacheData\n     */\n    public getTileCacheData(): Uint8Array {\n        if (!this.navMesh || !this._tileCache) {\n            throw new Error(\"There is no TileCache generated.\");\n        }\n        return this.bjsRECAST.exportTileCache(this.navMesh, this._tileCache);\n    }\n\n    /**\n     * Disposes\n     */\n    public dispose() {\n        this._crowd?.dispose();\n        this.navMesh?.destroy();\n        this._navMeshQuery?.destroy();\n        this._tileCache?.destroy();\n    }\n\n    /**\n     * Creates a cylinder obstacle and add it to the navigation\n     * @param position world position\n     * @param radius cylinder radius\n     * @param height cylinder height\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     * @returns the obstacle freshly created\n     */\n    public addCylinderObstacle(position: IVector3Like, radius: number, height: number, doNotWaitForCacheUpdate = false): Nullable<IObstacle> {\n        const obstacleResult = this._tileCache?.addCylinderObstacle(position, radius, height);\n        if (!obstacleResult?.success) {\n            return null;\n        }\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return (obstacleResult.obstacle as IObstacle) ?? null;\n    }\n\n    /**\n     * Creates an oriented box obstacle and add it to the navigation\n     * @param position world position\n     * @param extent box size\n     * @param angle angle in radians of the box orientation on Y axis\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     * @returns the obstacle freshly created\n     */\n    public addBoxObstacle(position: IVector3Like, extent: IVector3Like, angle: number, doNotWaitForCacheUpdate = false): Nullable<IObstacle> {\n        const obstacleResult = this._tileCache?.addBoxObstacle(position, extent, angle);\n        if (!obstacleResult?.success) {\n            return null;\n        }\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return (obstacleResult.obstacle as IObstacle) ?? null;\n    }\n\n    /**\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n     * @param obstacle obstacle to remove from the navigation\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     *\n     */\n    public removeObstacle(obstacle: IObstacle, doNotWaitForCacheUpdate = false): void {\n        this._tileCache?.removeObstacle(obstacle);\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n    }\n\n    /**\n     * If this plugin is supported\n     * @returns true if plugin is supported\n     */\n    public isSupported(): boolean {\n        return !!this.bjsRECAST;\n    }\n\n    /**\n     * Returns the seed used for randomized functions like `getRandomPointAround`\n     * @returns seed number\n     */\n    public getRandomSeed(): number {\n        return this.bjsRECAST.getRandomSeed();\n    }\n\n    /**\n     * Set the seed used for randomized functions like `getRandomPointAround`\n     * @param seed number used as seed for random functions\n     */\n    public setRandomSeed(seed: number): void {\n        this.bjsRECAST.setRandomSeed(seed);\n    }\n\n    // New funccntions beyond the INavigationEnginePlugin interface\n\n    /**\n     * Perform a raycast on the navmesh\n     * @param start start position\n     * @param end end position\n     * @returns if a direct path exists between start and end, and the hit point if any\n     */\n    public raycast(start: IVector3Like, end: IVector3Like) {\n        const nearestStartPoly = this._navMeshQuery.findNearestPoly(start);\n        const raycastResult = this._navMeshQuery.raycast(nearestStartPoly.nearestRef, start, end);\n\n        const hit = 0 < raycastResult.t && raycastResult.t < 1.0;\n        if (!hit) {\n            return {\n                hit: false,\n            };\n        } else {\n            TmpVectors.Vector3[0].set(start.x, start.y, start.z);\n            TmpVectors.Vector3[1].set(end.x, end.y, end.z);\n\n            const distanceToHitBorder = Vector3.Distance(TmpVectors.Vector3[0], TmpVectors.Vector3[1]) * (raycastResult?.t ?? 0);\n            const direction = TmpVectors.Vector3[1].subtract(TmpVectors.Vector3[0]).normalize();\n            const hitPoint = TmpVectors.Vector3[0].add(direction.multiplyByFloats(distanceToHitBorder, distanceToHitBorder, distanceToHitBorder));\n\n            return {\n                hit: true,\n                hitPoint,\n            };\n        }\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position, and return the height of the polygon\n     * This is a more sophisiticated version of moveAlong that will use the height of the polygon at the end position\n     * @param position world position to start from\n     * @param velocity wvelocity of the movement\n     * @param options options for the function\n     * @returns the resulting point along the navmesh, the polygon reference id and the height of the polygon\n     */\n    public moveAlongWithVelocity(\n        position: IVector3Like,\n        velocity: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            /**\n             * The maximum number of polygons the output visited array can hold.\n             */\n            maxVisitedSize?: number;\n        }\n    ) {\n        const { point, polyRef } = this._navMeshQuery.findClosestPoint(\n            {\n                x: position.x,\n                y: position.y,\n                z: position.z,\n            },\n            options\n        );\n\n        const { resultPosition } = this._navMeshQuery.moveAlongSurface(\n            polyRef,\n            point,\n            {\n                x: point.x + velocity.x,\n                y: point.y + velocity.y,\n                z: point.z + velocity.z,\n            },\n            options\n        );\n        const polyHeightResult = this._navMeshQuery.getPolyHeight(polyRef, resultPosition);\n\n        return {\n            position: { x: resultPosition.x, y: polyHeightResult.success ? polyHeightResult.height : resultPosition.y, z: resultPosition.z },\n            polyRef: polyRef,\n            height: polyHeightResult.height,\n        };\n    }\n\n    /**\n     * Handles common post-processing and validation of navmesh creation results\n     * @param result The partial result from navmesh creation\n     * @returns The validated and complete CreateNavMeshresult\n     */\n    private _processNavMeshResult(result: Nullable<Partial<CreateNavMeshResult>>): CreateNavMeshResult {\n        if (!result?.navMesh || !result?.navMeshQuery) {\n            throw new Error(\"Unable to create navmesh. No navMesh or navMeshQuery returned.\");\n        }\n\n        this.navMesh = result.navMesh;\n        this._navMeshQuery = result.navMeshQuery;\n        this._intermediates = result.intermediates;\n        this._tileCache = result.tileCache;\n\n        return {\n            navMesh: result.navMesh,\n            navMeshQuery: result.navMeshQuery,\n            intermediates: result.intermediates,\n            tileCache: result.tileCache, // tileCache is optional\n        };\n    }\n\n    private _preprocessParameters(parameters: INavMeshParametersV2) {\n        // if maxObstacles is not defined, set it to a default value and set a default tile size if not defined\n        if (parameters.maxObstacles === undefined) {\n            parameters.tileSize = parameters.tileSize ?? 32; // maxObstacles will trigger tile cache creation, so we need a tile size\n            parameters.maxObstacles = DefaultMaxObstacles;\n        }\n\n        parameters.walkableSlopeAngle = Math.max(0.1, parameters.walkableSlopeAngle ?? 60);\n    }\n}\n"]}