{"version":3,"file":"atmospherePBRMaterialPlugin.js","sourceRoot":"","sources":["../../../../dev/addons/src/atmosphere/atmospherePBRMaterialPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Atmosphere } from \"./atmosphere\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport { Vector3FromFloatsToRef, Vector3ScaleToRef } from \"core/Maths/math.vector.functions\";\r\n\r\nclass AtmospherePBRMaterialDefines extends MaterialDefines {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public USE_AERIAL_PERSPECTIVE_LUT: boolean;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public APPLY_AERIAL_PERSPECTIVE_INTENSITY = false;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS = false;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public SAMPLE_TRANSMITTANCE_LUT = true;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public EXCLUDE_RAY_MARCHING_FUNCTIONS = true;\r\n\r\n    /**\r\n     * Constructs the {@link AtmospherePBRMaterialDefines}.\r\n     * @param useAerialPerspectiveLut - Whether to use the aerial perspective LUT.\r\n     */\r\n    constructor(useAerialPerspectiveLut: boolean) {\r\n        super();\r\n        this.USE_AERIAL_PERSPECTIVE_LUT = useAerialPerspectiveLut;\r\n    }\r\n}\r\n\r\nconst OriginOffsetUniformName = \"originOffsetKm\";\r\nconst InverseViewportSizeUniformName = \"inverseViewportSize\";\r\n\r\nconst UboArray = [\r\n    { name: OriginOffsetUniformName, size: 3, type: \"vec3\" },\r\n    { name: \"_atmoPbrPadding1\", size: 1, type: \"float\" },\r\n    { name: InverseViewportSizeUniformName, size: 2, type: \"vec2\" },\r\n];\r\nconst MakeUniforms = (atmosphere: Atmosphere) => ({\r\n    ubo: UboArray,\r\n    fragment: `uniform vec2 ${InverseViewportSizeUniformName};\\nuniform vec3 ${OriginOffsetUniformName};\\n`,\r\n    externalUniforms: atmosphere.uniformBuffer.getUniformNames(),\r\n});\r\n\r\nconst PluginName = \"AtmospherePBRMaterialPlugin\";\r\nconst PluginPriority = 600;\r\nconst OriginOffsetKm = { x: 0, y: 0, z: 0 };\r\n\r\n/**\r\n * Adds shading logic to a PBRMaterial that provides radiance, diffuse sky irradiance, and aerial perspective from the atmosphere.\r\n */\r\nexport class AtmospherePBRMaterialPlugin extends MaterialPluginBase {\r\n    /**\r\n     * Constructs the {@link AtmospherePBRMaterialPlugin}.\r\n     * @param material - The material to apply the plugin to.\r\n     * @param _atmosphere - The atmosphere to use for shading.\r\n     * @param _isAerialPerspectiveEnabled - Whether to apply aerial perspective.\r\n     */\r\n    constructor(\r\n        material: Material,\r\n        private readonly _atmosphere: Atmosphere,\r\n        private readonly _isAerialPerspectiveEnabled = false\r\n    ) {\r\n        super(\r\n            material,\r\n            PluginName,\r\n            PluginPriority,\r\n            {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                USE_CUSTOM_REFLECTION: _atmosphere.diffuseSkyIrradianceLut !== null,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_BEFORE_FOG: _isAerialPerspectiveEnabled,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                USE_AERIAL_PERSPECTIVE_LUT: _isAerialPerspectiveEnabled && _atmosphere.isAerialPerspectiveLutEnabled,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                APPLY_AERIAL_PERSPECTIVE_INTENSITY: _isAerialPerspectiveEnabled && _atmosphere.aerialPerspectiveIntensity !== 1.0,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS: _isAerialPerspectiveEnabled && _atmosphere.aerialPerspectiveRadianceBias !== 0.0,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                SAMPLE_TRANSMITTANCE_LUT: true,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                EXCLUDE_RAY_MARCHING_FUNCTIONS: true,\r\n            },\r\n            false, // addPluginToList -- false because we need to control when this is added to the list\r\n            true, // enable\r\n            true // resolveIncludes\r\n        );\r\n\r\n        this.doNotSerialize = true;\r\n\r\n        // This calls `getCode` so we need to do this after having initialized the class fields.\r\n        this._pluginManager._addPlugin(this);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getUniformBuffersNames(_ubos: string[]): void {\r\n        const uniformBuffer = this._atmosphere.uniformBuffer;\r\n        if (uniformBuffer.useUbo) {\r\n            _ubos.push(uniformBuffer.name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getUniforms() {\r\n        return MakeUniforms(this._atmosphere);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override isReadyForSubMesh(): boolean {\r\n        let isReady = true;\r\n        const atmosphere = this._atmosphere;\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            isReady = isReady && !!aerialPerspectiveLutRenderTarget?.isReady();\r\n        }\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        isReady = isReady && !!transmittanceLutRenderTarget?.isReady();\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getActiveTextures(_activeTextures: BaseTexture[]): void {\r\n        const atmosphere = this._atmosphere;\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            if (aerialPerspectiveLutRenderTarget) {\r\n                _activeTextures.push(aerialPerspectiveLutRenderTarget);\r\n            }\r\n        }\r\n\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        if (transmittanceLutRenderTarget) {\r\n            _activeTextures.push(transmittanceLutRenderTarget);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer): void {\r\n        const atmosphere = this._atmosphere;\r\n        const scene = atmosphere.scene;\r\n        const engine = scene.getEngine();\r\n\r\n        // Bind the atmosphere's uniform buffer to the effect.\r\n        const effect = uniformBuffer.currentEffect;\r\n        if (effect) {\r\n            this._atmosphere.bindUniformBufferToEffect(effect);\r\n        }\r\n\r\n        // Need the offset to apply which will take a world space position and convert it to a global space position in the atmosphere.\r\n        // If floating origin mode is enabled, that offset is the floating origin offset.\r\n        // If not, it's an offset up the Y-axis by the planet radius.\r\n        uniformBuffer.updateVector3(\r\n            OriginOffsetUniformName,\r\n            scene.floatingOriginMode\r\n                ? Vector3ScaleToRef(scene.floatingOriginOffset, 0.001, OriginOffsetKm) // Convert to kilometers\r\n                : Vector3FromFloatsToRef(0, atmosphere.physicalProperties.planetRadius, 0, OriginOffsetKm) // planetRadius is already in kilometers\r\n        );\r\n\r\n        const width = engine.getRenderWidth();\r\n        const height = engine.getRenderHeight();\r\n        uniformBuffer.updateFloat2(InverseViewportSizeUniformName, 1.0 / width, 1.0 / height);\r\n\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            uniformBuffer.setTexture(\"aerialPerspectiveLut\", aerialPerspectiveLutRenderTarget);\r\n        }\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        uniformBuffer.setTexture(\"transmittanceLut\", transmittanceLutRenderTarget);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override prepareDefines(defines: AtmospherePBRMaterialDefines): void {\r\n        const lastUseAerialPerspectiveLut = defines.USE_AERIAL_PERSPECTIVE_LUT;\r\n        const lastApplyAerialPerspectiveIntensity = defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY;\r\n        const lastApplyAerialPerspectiveRadianceBias = defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS;\r\n        defines.USE_AERIAL_PERSPECTIVE_LUT = this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled;\r\n        defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY = this._isAerialPerspectiveEnabled && this._atmosphere.aerialPerspectiveIntensity !== 1.0;\r\n        defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS = this._isAerialPerspectiveEnabled && this._atmosphere.aerialPerspectiveRadianceBias !== 0.0;\r\n        if (\r\n            lastUseAerialPerspectiveLut !== defines.USE_AERIAL_PERSPECTIVE_LUT ||\r\n            lastApplyAerialPerspectiveIntensity !== defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY ||\r\n            lastApplyAerialPerspectiveRadianceBias !== defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\r\n        ) {\r\n            defines.markAllAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"transmittanceLut\");\r\n        if (this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled) {\r\n            samplers.push(\"aerialPerspectiveLut\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getCustomCode(shaderType: string): Nullable<Record<string, string>> {\r\n        // Assumed inputs are light0, vPositionW, normalW.\r\n        // Only works for directional lights.\r\n        if (shaderType !== \"fragment\") {\r\n            return null;\r\n        }\r\n\r\n        const useUbo = this._atmosphere.scene.getEngine().supportsUniformBuffers;\r\n        const directionToLightSnippet = useUbo ? \"-light0.vLightData.xyz\" : \"-vLightData0.xyz\";\r\n\r\n        const useAtmosphereUbo = this._atmosphere.uniformBuffer.useUbo;\r\n        const atmosphereImportSnippet = useAtmosphereUbo ? \"#include<atmosphereUboDeclaration>\" : \"#include<atmosphereFragmentDeclaration>\";\r\n\r\n        return {\r\n            CUSTOM_FRAGMENT_DEFINITIONS:\r\n                this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled\r\n                    ? `uniform sampler2D transmittanceLut;\\r\\nprecision highp sampler2DArray;\\r\\nuniform sampler2DArray aerialPerspectiveLut;\\r\\n${atmosphereImportSnippet}\\r\\n#include<atmosphereFunctions>`\r\n                    : `uniform sampler2D transmittanceLut;\\r\\n${atmosphereImportSnippet}\\r\\n#include<atmosphereFunctions>`,\r\n            CUSTOM_LIGHT0_COLOR: `\r\n            {\r\n                vec3 positionGlobal = 0.001 * vPositionW + ${OriginOffsetUniformName};\r\n                float positionRadius = length(positionGlobal);\r\n                vec3 geocentricNormal = positionGlobal / positionRadius;\r\n                vec3 directionToLight = ${directionToLightSnippet};\r\n                float cosAngleLightToZenith = dot(directionToLight, geocentricNormal);\r\n                diffuse0 = lightIntensity * sampleTransmittanceLut(transmittanceLut, positionRadius, cosAngleLightToZenith);\r\n            }\r\n`,\r\n            CUSTOM_REFLECTION: `\r\n            {\r\n                vec3 positionGlobal =  0.001 * vPositionW + ${OriginOffsetUniformName};\r\n                float positionRadius = length(positionGlobal);\r\n                vec3 geocentricNormal = positionGlobal / positionRadius;\r\n\r\n                vec3 directionToLight = ${directionToLightSnippet};\r\n                float cosAngleLightToZenith = dot(directionToLight, geocentricNormal);\r\n\r\n                vec2 uv = vec2(0.5 + 0.5 * cosAngleLightToZenith, (positionRadius - planetRadius) / atmosphereThickness);\r\n                float irradianceScaleT = 0.5 * dot(normalW, geocentricNormal) + 0.5;\r\n                float irradianceScale = ((-0.6652 * irradianceScaleT) + 1.5927) * irradianceScaleT + 0.1023;\r\n                vec3 environmentIrradiance = lightIntensity * sampleReflection(irradianceSampler, uv).rgb;\r\n\r\n                // Add a contribution here to estimate indirect lighting.\r\n                const float r = 0.2;\r\n                float indirect = getLuminance(environmentIrradiance) / max(0.00001, 1. - r);\r\n                environmentIrradiance *= irradianceScale;\r\n                environmentIrradiance += indirect;\r\n\r\n                environmentIrradiance += additionalDiffuseSkyIrradiance;\r\n\r\n                const float diffuseBrdf = 1. / PI;\r\n                environmentIrradiance *= diffuseBrdf * diffuseSkyIrradianceIntensity;\r\n\r\n                reflectionOut.environmentIrradiance = environmentIrradiance;\r\n                reflectionOut.environmentRadiance.rgb = reflectionOut.environmentIrradiance;\r\n            }\r\n`,\r\n            // TODO: Support full ray marching if USE_AERIAL_PERSPECTIVE_LUT is disabled.\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: `\r\n            #if USE_AERIAL_PERSPECTIVE_LUT\r\n            {\r\n                float distanceFromCameraKm = 0.001 * distance(vEyePosition.xyz, vPositionW);\r\n                vec4 aerialPerspective = vec4(0.);\r\n                if (sampleAerialPerspectiveLut(\r\n                        gl_FragCoord.xy * ${InverseViewportSizeUniformName},\r\n                        true,\r\n                        distanceFromCameraKm,\r\n                        NumAerialPerspectiveLutLayers,\r\n                        AerialPerspectiveLutKMPerSlice,\r\n                        AerialPerspectiveLutRangeKM,\r\n                        aerialPerspective)) {\r\n                    finalColor = aerialPerspective + (1. - aerialPerspective.a) * finalColor;\r\n                }\r\n            }\r\n            #endif\r\n`,\r\n        };\r\n    }\r\n}\r\n"]}