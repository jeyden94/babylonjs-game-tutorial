{"version":3,"file":"transmittanceLut.js","sourceRoot":"","sources":["../../../../dev/addons/src/atmosphere/transmittanceLut.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Atmosphere } from \"./atmosphere\";\r\nimport type { AtmospherePhysicalProperties } from \"./atmospherePhysicalProperties\";\r\nimport { Clamp, SmoothStep } from \"core/Maths/math.scalar.functions\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { EffectRenderer, EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { FromHalfFloat } from \"core/Misc/textureTools\";\r\nimport type { IColor3Like, IColor4Like, IVector2Like, IVector3Like } from \"core/Maths/math.like\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport { Sample2DRgbaToRef } from \"./sampling\";\r\nimport { Vector3Dot } from \"core/Maths/math.vector.functions\";\r\nimport \"./Shaders/fullscreenTriangle.vertex\";\r\nimport \"./Shaders/transmittance.fragment\";\r\n\r\nconst LutWidthPx = 256;\r\nconst LutHeightPx = 64;\r\nconst EffectiveDomainInUVSpace = { x: (LutWidthPx - 1.0) / LutWidthPx, y: (LutHeightPx - 1.0) / LutHeightPx };\r\nconst HalfTexelSize = { x: 0.5 / LutWidthPx, y: 0.5 / LutHeightPx };\r\nconst TransmittanceHorizonRange = 2.0 * HalfTexelSize.x;\r\nconst TransmittanceMaxUnoccludedU = 1.0 - 0.5 * TransmittanceHorizonRange;\r\n\r\nconst UseHalfFloat = false;\r\n\r\n// Temporary storage.\r\nconst Uv = { x: Number.NaN, y: Number.NaN } as IVector2Like;\r\nconst LightColorTemp = { r: Number.NaN, g: Number.NaN, b: Number.NaN } as IColor3Like;\r\nconst DirectionToLightTemp = { x: Number.NaN, y: Number.NaN, z: Number.NaN } as IVector3Like;\r\nconst Color4Temp = { r: Number.NaN, g: Number.NaN, b: Number.NaN, a: Number.NaN } as IColor4Like;\r\n\r\nconst ComputeLutUVToRef = (properties: AtmospherePhysicalProperties, radius: number, cosAngleLightToZenith: number, uv: IVector2Like): void => {\r\n    const radiusSquared = radius * radius;\r\n    const distanceToHorizon = Math.sqrt(Math.max(0.0, radiusSquared - properties.planetRadiusSquared));\r\n\r\n    const cosAngleLightToZenithSq = cosAngleLightToZenith * cosAngleLightToZenith;\r\n    const discriminant = radiusSquared * (cosAngleLightToZenithSq - 1.0) + properties.atmosphereRadiusSquared;\r\n    const distanceToAtmosphereEdge = Math.max(0.0, -radius * cosAngleLightToZenith + Math.sqrt(Math.max(0.0, discriminant)));\r\n\r\n    const minDistanceToAtmosphereEdge = Math.max(0.0, properties.atmosphereRadius - radius);\r\n    const maxDistanceToAtmosphereEdge = distanceToHorizon + properties.horizonDistanceToAtmosphereEdge;\r\n    const cosAngleLightToZenithCoordinate =\r\n        (distanceToAtmosphereEdge - minDistanceToAtmosphereEdge) / Math.max(0.000001, maxDistanceToAtmosphereEdge - minDistanceToAtmosphereEdge);\r\n    const distanceToHorizonCoordinate = distanceToHorizon / Math.max(0.000001, properties.horizonDistanceToAtmosphereEdge);\r\n\r\n    // Unit to UV.\r\n    uv.x = EffectiveDomainInUVSpace.x * cosAngleLightToZenithCoordinate + HalfTexelSize.x;\r\n    uv.y = EffectiveDomainInUVSpace.y * distanceToHorizonCoordinate + HalfTexelSize.y;\r\n};\r\n\r\nconst SampleLutToRef = (\r\n    properties: AtmospherePhysicalProperties,\r\n    lutData: Uint8Array | Uint16Array,\r\n    positionDistanceToOrigin: number,\r\n    cosAngleLightToZenith: number,\r\n    result: IColor4Like\r\n): void => {\r\n    if (positionDistanceToOrigin > properties.atmosphereRadius) {\r\n        result.r = result.g = result.b = result.a = 1.0;\r\n        return;\r\n    }\r\n\r\n    ComputeLutUVToRef(properties, positionDistanceToOrigin, cosAngleLightToZenith, Uv);\r\n    Sample2DRgbaToRef(Uv.x, Uv.y, LutWidthPx, LutHeightPx, lutData, result, UseHalfFloat ? FromHalfFloat : (value) => value / 255.0);\r\n\r\n    const weight = Clamp(SmoothStep(1.0, 0.0, Clamp((Uv.x - TransmittanceMaxUnoccludedU) / TransmittanceHorizonRange)));\r\n    result.r *= weight;\r\n    result.g *= weight;\r\n    result.b *= weight;\r\n    result.a *= weight;\r\n};\r\n\r\n/**\r\n * The transmittance LUT can be used to get the radiance from an external light source arriving a given point, accounting for atmospheric scattering.\r\n */\r\nexport class TransmittanceLut {\r\n    /**\r\n     * Listen to this observer to know when the LUT data has been updated.\r\n     * This is typically infrequent (once at startup), but also happens whenever the atmosphere's properties change.\r\n     */\r\n    public readonly onUpdatedObservable = new Observable<void>();\r\n\r\n    private readonly _atmosphere: Atmosphere;\r\n    private _lutData: Uint8Array | Uint16Array = new Uint8Array(0);\r\n    private _renderTarget: Nullable<RenderTargetTexture>;\r\n    private _effectWrapper: Nullable<EffectWrapper>;\r\n    private _effectRenderer: Nullable<EffectRenderer>;\r\n    private _isDirty = true;\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * True if the LUT has been rendered.\r\n     */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * The render target that contains the transmittance LUT.\r\n     * @throws if the LUT has been disposed.\r\n     */\r\n    public get renderTarget(): RenderTargetTexture {\r\n        if (this._isDisposed || this._renderTarget === null) {\r\n            throw new Error();\r\n        }\r\n        return this._renderTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructs the {@link TransmittanceLut}.\r\n     * @param atmosphere - The atmosphere that owns this LUT.\r\n     */\r\n    constructor(atmosphere: Atmosphere) {\r\n        this._atmosphere = atmosphere;\r\n\r\n        const scene = this._atmosphere.scene;\r\n        const engine = scene.getEngine();\r\n        const useHalfFloat = UseHalfFloat && engine.getCaps().textureHalfFloatRender;\r\n\r\n        const name = \"atmo-transmittance\";\r\n        const renderTarget = (this._renderTarget = new RenderTargetTexture(name, { width: LutWidthPx, height: LutHeightPx }, scene, {\r\n            type: useHalfFloat ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            gammaSpace: false,\r\n        }));\r\n        renderTarget.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.anisotropicFilteringLevel = 1;\r\n        renderTarget.skipInitialClear = true;\r\n\r\n        const atmosphereUbo = atmosphere.uniformBuffer;\r\n        const useUbo = atmosphereUbo.useUbo;\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine,\r\n            name,\r\n            vertexShader: \"fullscreenTriangle\",\r\n            fragmentShader: \"transmittance\",\r\n            attributeNames: [\"position\"],\r\n            uniformNames: [\"depth\", ...(useUbo ? [] : atmosphereUbo.getUniformNames())],\r\n            uniformBuffers: useUbo ? [atmosphereUbo.name] : [],\r\n            defines: [\"#define POSITION_VEC2\"],\r\n            useShaderStore: true,\r\n        });\r\n\r\n        this._effectRenderer = new EffectRenderer(engine, {\r\n            // Full screen triangle.\r\n            indices: [0, 2, 1],\r\n            positions: [-1, -1, -1, 3, 3, -1],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the transmittance of an external light through the atmosphere to a point specified by its distance to the planet center and its geocentric normal.\r\n     * The result is always a linear space color.\r\n     * @param directionToLight - The direction to the light source.\r\n     * @param pointRadius - The distance from the origin to the point.\r\n     * @param pointGeocentricNormal - The normal of the point.\r\n     * @param result - The color to write the result to.\r\n     * @returns The result color.\r\n     */\r\n    public getTransmittedColorToRef<T extends IColor3Like>(directionToLight: IVector3Like, pointRadius: number, pointGeocentricNormal: IVector3Like, result: T): T {\r\n        if (this._lutData[0] !== undefined) {\r\n            const cosAngleLightToZenith = Vector3Dot(directionToLight, pointGeocentricNormal);\r\n            SampleLutToRef(this._atmosphere.physicalProperties, this._lutData, pointRadius, cosAngleLightToZenith, Color4Temp);\r\n            result.r = Color4Temp.r;\r\n            result.g = Color4Temp.g;\r\n            result.b = Color4Temp.b;\r\n        } else {\r\n            // Fallback.\r\n            result.r = result.g = result.b = 1.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Derives light color from the transmittance at a point specified by its distance to the planet center and its geocentric normal.\r\n     * @param light - The light to update.\r\n     * @param pointRadius - The distance from the origin to the point.\r\n     * @param pointGeocentricNormal - The normal of the point.\r\n     */\r\n    public updateLightParameters(light: DirectionalLight, pointRadius: number, pointGeocentricNormal: IVector3Like): void {\r\n        const lightDirection = light.direction;\r\n        DirectionToLightTemp.x = -lightDirection.x;\r\n        DirectionToLightTemp.y = -lightDirection.y;\r\n        DirectionToLightTemp.z = -lightDirection.z;\r\n        this.getTransmittedColorToRef(DirectionToLightTemp, pointRadius, pointGeocentricNormal, LightColorTemp);\r\n\r\n        light.diffuse.copyFromFloats(LightColorTemp.r, LightColorTemp.g, LightColorTemp.b);\r\n        light.specular.copyFromFloats(LightColorTemp.r, LightColorTemp.g, LightColorTemp.b);\r\n    }\r\n\r\n    /**\r\n     * Renders the LUT if needed.\r\n     * @returns true if the LUT was rendered.\r\n     */\r\n    public render(): boolean {\r\n        // Only need to render the LUT once.\r\n        const effectWrapper = this._effectWrapper;\r\n        if (!this._isDirty || !effectWrapper?.isReady() || !this._renderTarget?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._atmosphere.scene.getEngine();\r\n\r\n        engine.bindFramebuffer(this.renderTarget.renderTarget!, undefined, undefined, undefined, true);\r\n\r\n        const effectRenderer = this._effectRenderer!;\r\n        effectRenderer.applyEffectWrapper(effectWrapper);\r\n\r\n        effectRenderer.saveStates();\r\n        effectRenderer.setViewport();\r\n\r\n        const effect = effectWrapper.effect;\r\n        effectRenderer.bindBuffers(effect);\r\n\r\n        this._atmosphere.bindUniformBufferToEffect(effect);\r\n\r\n        effect.setFloat(\"depth\", 0);\r\n\r\n        effectRenderer.draw();\r\n\r\n        effectRenderer.restoreStates();\r\n        engine.restoreDefaultFramebuffer();\r\n\r\n        this._isDirty = false;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        void this.renderTarget.readPixels(0, 0, undefined, undefined, UseHalfFloat /* noDataConversion */)?.then((value: ArrayBufferView) => {\r\n            if (this._isDisposed) {\r\n                return;\r\n            }\r\n            this._lutData = value as Uint8Array | Uint16Array;\r\n            this.onUpdatedObservable.notifyObservers();\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Marks the LUT as needing to be rendered.\r\n     */\r\n    public markDirty(): void {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the LUT and its resources.\r\n     */\r\n    public dispose(): void {\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n        this._effectWrapper?.dispose();\r\n        this._effectWrapper = null;\r\n        this._effectRenderer?.dispose();\r\n        this._effectRenderer = null;\r\n        this._isDisposed = true;\r\n    }\r\n}\r\n"]}