// Do not edit.
import { ShaderStore } from "@babylonjs/core/Engines/shaderStore.js";
import "../Shaders/ShadersInclude/atmosphereFragmentDeclaration.js";
import "../Shaders/ShadersInclude/atmosphereUboDeclaration.js";
import "@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js";
import "../Shaders/ShadersInclude/depthFunctions.js";
import "../Shaders/ShadersInclude/atmosphereFunctions.js";
const name = "compositeAerialPerspectivePixelShader";
const shader = `precision highp float;precision highp sampler2D;precision highp sampler2DArray;
#include<__decl__atmosphereFragment>
#if USE_AERIAL_PERSPECTIVE_LUT
uniform sampler2DArray aerialPerspectiveLut;
#endif
uniform sampler2D depthTexture;uniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;
#include<helperFunctions>
#include<depthFunctions>
#include<atmosphereFunctions>
varying vec2 uv;varying vec3 positionOnNearPlane;void main() {gl_FragColor=vec4(0.);float depth=textureLod(depthTexture,uv,0.).r;if (depth>=1.) {discard;}
vec3 rayDirection=normalize(positionOnNearPlane);float distanceFromCamera =
reconstructDistanceFromCamera(
depth,
rayDirection,
cameraForward,
cameraNearPlane);float distanceToSurface=distanceFromCamera/1000.;vec4 aerialPerspective=vec4(0.);if (sampleAerialPerspectiveLut(
uv,
false,
distanceToSurface,
NumAerialPerspectiveLutLayers,
AerialPerspectiveLutKMPerSlice,
AerialPerspectiveLutRangeKM,
aerialPerspective)) {
#ifndef APPLY_TRANSMITTANCE_BLENDING
aerialPerspective.a=0.;
#endif
gl_FragColor=aerialPerspective;} else {bool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(
clampedCameraPositionGlobal,
clampedCameraRadius,
cameraGeocentricNormal,
rayDirection,
intersectsAtmosphere,
cameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {gl_FragColor=vec4(0.);return;}
vec3 transmittance;vec3 radiance;bool isAerialPerspectiveLut=clampedCameraRadius<atmosphereRadius;integrateScatteredRadiance(
isAerialPerspectiveLut,
atmosphereExposure*lightIntensity,
transmittanceLut,
multiScatteringLut,
multiScatteringIntensity,
cameraPositionGlobalClampedToTopOfAtmosphere,
rayDirection,
directionToLight,
100000000.,
SkyViewLutSampleCount,
distanceToSurface,
radiance,
transmittance);float transparency=1.-avg(transmittance);gl_FragColor =
applyAerialPerspectiveRadianceBias(
applyAerialPerspectiveIntensity(
applyAerialPerspectiveSaturation(vec4(radiance,transparency))));
#ifndef APPLY_TRANSMITTANCE_BLENDING
gl_FragColor.a=0.;
#endif
}
#if OUTPUT_TO_SRGB
gl_FragColor=toGammaSpace(gl_FragColor);
#endif
}`;
// Sideeffect
if (!ShaderStore.ShadersStore[name]) {
    ShaderStore.ShadersStore[name] = shader;
}
/** @internal */
export const compositeAerialPerspectivePixelShader = { name, shader };
//# sourceMappingURL=compositeAerialPerspective.fragment.js.map