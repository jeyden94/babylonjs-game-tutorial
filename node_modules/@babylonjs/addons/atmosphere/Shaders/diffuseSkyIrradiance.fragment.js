// Do not edit.
import { ShaderStore } from "@babylonjs/core/Engines/shaderStore.js";
import "../Shaders/ShadersInclude/atmosphereFragmentDeclaration.js";
import "../Shaders/ShadersInclude/atmosphereUboDeclaration.js";
import "@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js";
import "../Shaders/ShadersInclude/depthFunctions.js";
import "../Shaders/ShadersInclude/atmosphereFunctions.js";
import "@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js";
import "@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js";
import "@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js";
const name = "diffuseSkyIrradiancePixelShader";
const shader = `precision highp float;const float DiffuseSkyIrradianceLutSampleCount=32.0;
#include<__decl__atmosphereFragment>
uniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;
#include<helperFunctions>
#include<depthFunctions>
#include<atmosphereFunctions>
vec3 integrateForIrradiance(vec3 directionToLight,vec3 rayDirection,vec3 rayOrigin) {vec3 radiance;vec3 transmittance;integrateScatteredRadiance(
false,
1.,
transmittanceLut,
multiScatteringLut,
multiScatteringIntensity,
rayOrigin,
rayDirection.xzy,
directionToLight.xzy,
100000000.,
DiffuseSkyIrradianceLutSampleCount,
-1.,
radiance,
transmittance);return radiance;}
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
varying vec2 uv;void main() {vec2 unit=uvToUnit(uv,DiffuseSkyIrradianceLutDomainInUVSpace,DiffuseSkyIrradianceLutHalfTexelSize);float cosLightInclination=2.*unit.x-1.;float sinLightInclination=sqrtClamped(1.-cosLightInclination*cosLightInclination);vec3 directionToLight=normalize(vec3(0.,cosLightInclination,sinLightInclination));float radius=max(planetRadiusWithOffset,unit.y*atmosphereThickness+planetRadius);vec3 swappedDirectionToLight=vec3(directionToLight.x,directionToLight.z,directionToLight.y); 
vec3 irradiance=PI*irradiance(
swappedDirectionToLight,
vec2(radius,0.),
1.,
vec3(1.),
vec3(1.));float averageIrradiance=getLuminance(irradiance);vec3 newIrradiance=mix(irradiance,vec3(averageIrradiance),diffuseSkyIrradianceDesaturationFactor);float newIrradianceScale=getLuminance(newIrradiance);float rescaling=averageIrradiance/max(0.000001,newIrradianceScale);irradiance=newIrradiance*rescaling;gl_FragColor=vec4(irradiance,1.);}`;
// Sideeffect
if (!ShaderStore.ShadersStore[name]) {
    ShaderStore.ShadersStore[name] = shader;
}
/** @internal */
export const diffuseSkyIrradiancePixelShader = { name, shader };
//# sourceMappingURL=diffuseSkyIrradiance.fragment.js.map