{"version":3,"file":"atmosphereFunctions.js","sourceRoot":"","sources":["../../../../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/atmosphereFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,+CAAiC;AACvD,yEAA2D;AAE3D,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6Od,CAAC;AACF,aAAa;AACb,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,CAAC;IAC1C,WAAW,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACpD,CAAC;AACD,gBAAgB;AAChB,MAAM,CAAC,MAAM,mBAAmB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/intersectionFunctions\";\n\nconst name = \"atmosphereFunctions\";\nconst shader = `#include<intersectionFunctions>\nconst vec2 MultiScatteringLutSize=vec2(32.0,32.0);const vec2 MultiScatteringLutDomainInUVSpace=(MultiScatteringLutSize-vec2(1.0))/MultiScatteringLutSize;const vec2 MultiScatteringLutHalfTexelSize=vec2(0.5)/MultiScatteringLutSize;const float NumAerialPerspectiveLutLayers=32.0;const vec3 AerialPerspectiveLutSize=vec3(16.0,64.0,NumAerialPerspectiveLutLayers);const vec2 DiffuseSkyIrradianceLutSize=vec2(64.0,16.0);const vec2 DiffuseSkyIrradianceLutDomainInUVSpace=(DiffuseSkyIrradianceLutSize-vec2(1.0))/DiffuseSkyIrradianceLutSize;const vec2 DiffuseSkyIrradianceLutHalfTexelSize=vec2(0.5)/DiffuseSkyIrradianceLutSize;const vec2 SkyViewLutSize=vec2(128.0,128.0);const vec2 SkyViewLutDomainInUVSpace=(SkyViewLutSize-vec2(1.0))/SkyViewLutSize;const vec2 SkyViewLutHalfTexelSize=vec2(0.5)/SkyViewLutSize;const float AerialPerspectiveLutKMPerSlice=4.0;const float AerialPerspectiveLutRangeKM=AerialPerspectiveLutKMPerSlice*NumAerialPerspectiveLutLayers;const float TransmittanceSampleCount=128.0;const float SkyViewLutSampleCount=30.0;const vec2 TransmittanceLutSize=vec2(256.,64.);const vec2 TransmittanceLutDomainInUVSpace=(TransmittanceLutSize-vec2(1.))/TransmittanceLutSize;const vec2 TransmittanceLutHalfTexelSize=vec2(0.5)/TransmittanceLutSize;const float TransmittanceHorizonRange=2.*TransmittanceLutHalfTexelSize.x;const float TransmittanceMaxUnoccludedU=1.-0.5*TransmittanceHorizonRange;const float TransmittanceMinOccludedU=1.+0.5*TransmittanceHorizonRange;vec2 uvToUnit(vec2 uv,vec2 domainInUVSpace,vec2 halfTexelSize) {return (uv-halfTexelSize)/domainInUVSpace;}\nvec2 unitToUV(vec2 unit,vec2 domainInUVSpace,vec2 halfTexelSize) {return unit*domainInUVSpace+halfTexelSize;}\nfloat sphereIntersectNearest(vec3 rayOrigin,vec3 rayDirection,float sphereRadius) {vec2 result=sphereIntersectFromOrigin(rayOrigin,rayDirection,sphereRadius);float c=dot(rayOrigin,rayOrigin)-sphereRadius*sphereRadius;return c>=0.0 ?\nresult.y :\nresult.x;}\nvoid moveToTopAtmosphere(\nvec3 cameraPosition,\nfloat positionRadius,\nvec3 positionGeocentricNormal,\nvec3 rayDirection,\nout bool intersectsAtmosphere,\nout vec3 cameraPositionClampedToTopOfAtmosphere) {intersectsAtmosphere=true;cameraPositionClampedToTopOfAtmosphere=cameraPosition;if (positionRadius>atmosphereRadius) {float tTop=sphereIntersectNearest(cameraPosition,rayDirection,atmosphereRadius);if (tTop>=0.0) {vec3 upOffset=-planetRadiusOffset*positionGeocentricNormal;cameraPositionClampedToTopOfAtmosphere=cameraPosition+rayDirection*tTop+upOffset;} else {intersectsAtmosphere=false;}}}\nvoid getSkyViewUVFromParameters(\nbool intersectsGround,\nfloat cosHorizonAngleFromZenith,\nfloat cosAngleBetweenViewAndZenith,\nfloat cosAngleBetweenViewAndLightOnPlane,\nout vec2 uv)\n{vec2 unit=vec2(0.0);if (intersectsGround) {float coord=(cosAngleBetweenViewAndZenith+1.0)/(cosHorizonAngleFromZenith+1.0);coord=sqrtClamped(coord); \nunit.y=0.5*coord; } else {float coord=(cosAngleBetweenViewAndZenith-cosHorizonAngleFromZenith)/(1.0-cosHorizonAngleFromZenith);coord=sqrtClamped(coord); \nunit.y=0.5*coord+0.5; }\n{float coord=0.5-0.5*cosAngleBetweenViewAndLightOnPlane;unit.x=coord;}\nuv=unitToUV(unit,SkyViewLutDomainInUVSpace,SkyViewLutHalfTexelSize);}\n#if USE_SKY_VIEW_LUT && SAMPLE_SKY_VIEW_LUT\n#define inline\nvec4 sampleSkyViewLut(\nsampler2D skyViewLut,\nfloat positionRadius,\nvec3 geocentricNormal,\nvec3 rayDirection,\nvec3 directionToLight,\nfloat cosHorizonAngleFromZenith,\nout float cosAngleBetweenViewAndZenith,\nout bool isRayIntersectingGround) {cosAngleBetweenViewAndZenith=dot(rayDirection,geocentricNormal);if (positionRadius>atmosphereRadius) {float sinAngleBetweenViewAndNadir=sqrtClamped(1.-cosAngleBetweenViewAndZenith*cosAngleBetweenViewAndZenith);if (sinAngleBetweenViewAndNadir>sinCameraAtmosphereHorizonAngleFromNadir) {isRayIntersectingGround=false;return vec4(0.);}}\nvec3 sideVector=normalize(cross(geocentricNormal,rayDirection));vec3 forwardVector=normalize(cross(sideVector,geocentricNormal));vec2 lightOnPlane=normalize(vec2(dot(directionToLight,forwardVector),dot(directionToLight,sideVector)));float cosAngleBetweenViewAndLightOnPlane=lightOnPlane.x;float rayIntersectionScale=mix(0.95,1.,saturate((positionRadius-planetRadius)/atmosphereThickness));isRayIntersectingGround =\npositionRadius>planetRadius &&\n(rayIntersectionScale*cosAngleBetweenViewAndZenith)<=cosHorizonAngleFromZenith;vec2 uv;getSkyViewUVFromParameters(\nisRayIntersectingGround,\ncosHorizonAngleFromZenith,\ncosAngleBetweenViewAndZenith,\ncosAngleBetweenViewAndLightOnPlane,\nuv);return textureLod(skyViewLut,uv,0.);}\n#endif\nfloat computeRayleighPhase(float onePlusCosThetaSq) {return 0.0596831037*onePlusCosThetaSq;}\nfloat computeMiePhaseCornetteShanks(float cosTheta,float onePlusCosThetaSq) {const float g=0.8;const float gSquared=g*g;const float oneMinusGSquared=1.-gSquared;const float onePlusGSquared=1.+gSquared;const float twoPlusGSquared=2.+gSquared;const float twoG=2.*g;const float threeOverEightPi=3./(8.*PI);return threeOverEightPi*oneMinusGSquared*onePlusCosThetaSq/(twoPlusGSquared*pow(onePlusGSquared-twoG*cosTheta,1.5));}\nfloat computeOzoneDensity(float normalizedViewHeight) {const float MinOzoneDensity=0.135;const float OneMinusMinOzoneDensity=1.-MinOzoneDensity;const float OzoneStartHeight=.15; \nconst float PeakOzoneHeight=.25;const float MaxOzoneHeight=0.6;const float InverseRampupDistance=1./(PeakOzoneHeight-OzoneStartHeight);const float InverseRampdownDistance=1./(MaxOzoneHeight-PeakOzoneHeight);float lowerAtmosphereDensity=MinOzoneDensity+OneMinusMinOzoneDensity*max(0.,normalizedViewHeight-OzoneStartHeight)*InverseRampupDistance;float sqrtUpperAtmosphereDensity=max(0.,1.-(normalizedViewHeight-PeakOzoneHeight)*InverseRampdownDistance);float upperAtmosphereDensity=sqrtUpperAtmosphereDensity*sqrtUpperAtmosphereDensity;float densityOzone=normalizedViewHeight<PeakOzoneHeight ? lowerAtmosphereDensity : upperAtmosphereDensity;return densityOzone;}\nvoid sampleMediumRGB(\nfloat viewHeight,\nout vec3 scatteringRayleigh,\nout vec3 scatteringMie,\nout vec3 extinction,\nout vec3 scattering) {float normalizedViewHeight=saturate(viewHeight*inverseAtmosphereThickness);float densityMie=exp(-83.333*normalizedViewHeight);float densityRayleigh=exp(-12.5*normalizedViewHeight);float densityOzone=computeOzoneDensity(normalizedViewHeight);scatteringRayleigh=densityRayleigh*peakRayleighScattering;scatteringMie=densityMie*peakMieScattering;scattering=scatteringMie+scatteringRayleigh;vec3 extinctionRayleigh=scatteringRayleigh;vec3 extinctionMie=densityMie*peakMieExtinction;vec3 extinctionOzone=densityOzone*peakOzoneAbsorption;extinction=extinctionRayleigh+extinctionMie+extinctionOzone;}\nvec3 computeTransmittance(vec3 rayOriginGlobal,vec3 rayDirection,float tMax,float sampleCount) {vec3 opticalDepth=vec3(0.);float t=0.;float sampleSegmentWeight=tMax/sampleCount;const float sampleSegmentT=0.3;for (float s=0.; s<sampleCount; s+=1.) {float newT=sampleSegmentWeight*(s+sampleSegmentT);float dt=newT-t;t=newT;vec3 scatteringRayleigh,scatteringMie,extinction,scattering;vec3 samplePositionGlobal=rayOriginGlobal+t*rayDirection;sampleMediumRGB(length(samplePositionGlobal)-planetRadius,scatteringRayleigh,scatteringMie,extinction,scattering);opticalDepth+=extinction*dt;}\nreturn exp(-opticalDepth);}\n#if defined(SAMPLE_TRANSMITTANCE_LUT) || !defined(EXCLUDE_RAY_MARCHING_FUNCTIONS)\nvec2 getTransmittanceUV(float radius,float cosAngleLightToZenith,out float distanceToHorizon) {float radiusSquared=radius*radius;distanceToHorizon=sqrtClamped(radiusSquared-planetRadiusSquared);float cosAngleLightToZenithSquared=cosAngleLightToZenith*cosAngleLightToZenith;float discriminant=radiusSquared*(cosAngleLightToZenithSquared-1.)+atmosphereRadiusSquared;float distanceToAtmosphereEdge=max(0.,-radius*cosAngleLightToZenith+sqrtClamped(discriminant));float minDistanceToAtmosphereEdge=max(0.,atmosphereRadius-radius);float maxDistanceToAtmosphereEdge=distanceToHorizon+horizonDistanceToAtmosphereEdge;float cosAngleLightToZenithCoordinate=(distanceToAtmosphereEdge-minDistanceToAtmosphereEdge)/max(0.000001,maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);float distanceToHorizonCoordinate=distanceToHorizon/max(0.000001,horizonDistanceToAtmosphereEdge);vec2 unit=vec2(cosAngleLightToZenithCoordinate,distanceToHorizonCoordinate);return unit*TransmittanceLutDomainInUVSpace+TransmittanceLutHalfTexelSize; }\n#define inline\nvec4 sampleTransmittanceLut(sampler2D transmittanceLut,float positionRadius,float cosAngleLightToZenith) {float distanceToHorizon;vec2 uv=getTransmittanceUV(positionRadius,cosAngleLightToZenith,distanceToHorizon);float weight=smoothstep(TransmittanceMinOccludedU,TransmittanceMaxUnoccludedU,uv.x);return weight*textureLod(transmittanceLut,uv,0.);}\n#endif\n#ifndef EXCLUDE_RAY_MARCHING_FUNCTIONS\n#define inline\nvec3 sampleMultiScatteringLut(sampler2D multiScatteringLut,float radius,float cosAngleLightToZenith) {vec2 unit=vec2(0.5+0.5*cosAngleLightToZenith,(radius-planetRadius)/atmosphereThickness);vec2 uv=unitToUV(unit,MultiScatteringLutDomainInUVSpace,MultiScatteringLutHalfTexelSize);vec3 multiScattering=textureLod(multiScatteringLut,uv,0.).rgb;return max(minMultiScattering,multiScattering);}\nconst float uniformPhase=RECIPROCAL_PI4;\n#define inline\nvoid integrateScatteredRadiance(\nbool isAerialPerspectiveLut,\nfloat lightIntensity,\nsampler2D transmittanceLut,\n#ifndef COMPUTE_MULTI_SCATTERING\nsampler2D multiScatteringLut,\nfloat multiScatteringIntensity,\n#endif\nvec3 rayOriginGlobal,\nvec3 rayDirection,\nvec3 directionToLight,\nfloat tMaxMax,\nfloat sampleCount,\nfloat distanceToSurface,\nout vec3 radiance,\nout vec3 transmittance\n#if COMPUTE_MULTI_SCATTERING\n,out vec3 multiScattering\n#endif\n) {radiance=vec3(0.);transmittance=vec3(1.);\n#if COMPUTE_MULTI_SCATTERING\nmultiScattering=vec3(0.);\n#endif\nfloat tBottom=sphereIntersectNearest(rayOriginGlobal,rayDirection,planetRadius);float tTop=sphereIntersectNearest(rayOriginGlobal,rayDirection,atmosphereRadius);float tMax=0.;if (tBottom<0.) {if (tTop<0.) {return;} else {tMax=tTop;}} else {if (tTop>0.) {if (isAerialPerspectiveLut) {tMax=tTop;} else {tMax=min(tBottom,tTop);}}}\nif (distanceToSurface>0. && distanceToSurface<tMax) {tMax=distanceToSurface;}\ntMax=min(tMax,tMaxMax);\n#ifndef COMPUTE_MULTI_SCATTERING\nfloat cosTheta=dot(rayDirection,directionToLight);float onePlusCosThetaSq=1.+cosTheta*cosTheta;float rayleighPhase=computeRayleighPhase(onePlusCosThetaSq);float miePhase=computeMiePhaseCornetteShanks(cosTheta,onePlusCosThetaSq);\n#endif\nfloat transmittanceScale=isAerialPerspectiveLut ? aerialPerspectiveTransmittanceScale : 1.;float t=0.;float sampleSegmentWeight=tMax/sampleCount;const float sampleSegmentT=0.3;for (float s=0.; s<sampleCount; s+=1.) {float newT=sampleSegmentWeight*(s+sampleSegmentT);float dt=newT-t;t=newT;vec3 samplePositionGlobal=rayOriginGlobal+t*rayDirection;float sampleRadiusGlobal=length(samplePositionGlobal);vec3 sampleGeocentricNormal=samplePositionGlobal/sampleRadiusGlobal;float sampleCosAngleLightToZenith=dot(directionToLight,sampleGeocentricNormal);vec3 scatteringRayleigh,scatteringMie,extinction,scattering;sampleMediumRGB(sampleRadiusGlobal-planetRadius,scatteringRayleigh,scatteringMie,extinction,scattering);vec3 transmittanceToLight=sampleTransmittanceLut(transmittanceLut,sampleRadiusGlobal,sampleCosAngleLightToZenith).rgb;\n#if COMPUTE_MULTI_SCATTERING\nvec3 phaseTimesScattering=uniformPhase*scattering;vec3 S=transmittanceToLight*phaseTimesScattering;\n#else\nvec3 phaseTimesScattering=scatteringMie*miePhase+scatteringRayleigh*rayleighPhase;vec3 multiScatteredRadiance=sampleMultiScatteringLut(multiScatteringLut,sampleRadiusGlobal,sampleCosAngleLightToZenith);vec3 S=transmittanceScale*transmittanceToLight*phaseTimesScattering+multiScatteringIntensity*multiScatteredRadiance*scattering;\n#endif\nvec3 sampleOpticalDepth=extinction*dt;vec3 sampleTransmittance=exp(-sampleOpticalDepth);vec3 clampedExtinction=max(vec3(0.0000001),extinction);vec3 SInt=(S-S*sampleTransmittance)/clampedExtinction;radiance+=transmittance*SInt;\n#if COMPUTE_MULTI_SCATTERING\nvec3 MSInt=(scattering-scattering*sampleTransmittance)/clampedExtinction;multiScattering+=transmittance*MSInt;\n#endif\ntransmittance*=sampleTransmittance;}\n#if USE_GROUND_ALBEDO\nif (tMax==tBottom && tBottom>0.) {vec3 planetPos=rayOriginGlobal+tBottom*rayDirection;float planetPosRadius=length(planetPos);vec3 planetPosGeocentricNormal=planetPos/planetPosRadius;float nDotL=dot(directionToLight,planetPosGeocentricNormal);vec3 lightTransmittance=sampleTransmittanceLut(transmittanceLut,planetPosRadius,nDotL).rgb;const float diffuseBrdf=RECIPROCAL_PI;radiance+=lightTransmittance*transmittance*groundAlbedo*(nDotL*diffuseBrdf);}\n#endif\nradiance*=lightIntensity;}\n#endif\nfloat layerIdxToAerialPerspectiveLayer(float layerIdx) {float layer=(layerIdx+1.)/NumAerialPerspectiveLutLayers;layer*=layer; \nlayer*=NumAerialPerspectiveLutLayers;return layer;}\nfloat toAerialPerspectiveDepth(float layer) {return layer*AerialPerspectiveLutKMPerSlice;}\nfloat toAerialPerspectiveLayer(float distance,float aerialPerspectiveLutDistancePerSlice) {return distance/aerialPerspectiveLutDistancePerSlice;}\nvec4 applyAerialPerspectiveSaturation(vec4 aerialPerspective) {float previousRadiance=getLuminance(aerialPerspective.rgb);aerialPerspective.rgb=mix(vec3(previousRadiance),aerialPerspective.rgb,aerialPerspectiveSaturation);return aerialPerspective;}\nvec4 applyAerialPerspectiveIntensity(vec4 aerialPerspective) {\n#if APPLY_AERIAL_PERSPECTIVE_INTENSITY\nif (aerialPerspectiveIntensity==0.) {aerialPerspective=vec4(0.);} else {float previousAlpha=aerialPerspective.a;aerialPerspective/=max(0.00001,previousAlpha);aerialPerspective*=pow(previousAlpha,1./aerialPerspectiveIntensity);}\n#endif\nreturn aerialPerspective;}\nvec4 applyAerialPerspectiveRadianceBias(vec4 aerialPerspective) {\n#if APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\nfloat originalRadiance=dot(aerialPerspective.rgb,LuminanceEncodeApprox);float targetRadiance=originalRadiance+aerialPerspectiveRadianceBias;if (originalRadiance>0.) {aerialPerspective*=max(0.,targetRadiance/originalRadiance);} else {aerialPerspective=max(vec4(0.),vec4(aerialPerspectiveRadianceBias));}\naerialPerspective.a=min(aerialPerspective.a,1.);\n#endif\nreturn aerialPerspective;}\nbool sampleAerialPerspectiveLut(\nvec2 screenUV,\nbool clampToLutRange,\nfloat distanceFromCamera,\nfloat numAerialPerspectiveLutLayers,\nfloat aerialPerspectiveLutKMPerSlice,\nfloat aerialPerspectiveLutRangeKM,\nout vec4 aerialPerspective) {aerialPerspective=vec4(0.);\n#if USE_AERIAL_PERSPECTIVE_LUT\nif (distanceFromCamera>0. &&\n(clampToLutRange || distanceFromCamera<aerialPerspectiveLutRangeKM) &&\nclampedCameraRadius<=atmosphereRadius) {float layer=toAerialPerspectiveLayer(distanceFromCamera,aerialPerspectiveLutKMPerSlice);float normalizedLayer=sqrt(layer/numAerialPerspectiveLutLayers); \nlayer=min(normalizedLayer*numAerialPerspectiveLutLayers,numAerialPerspectiveLutLayers);float weight=min(layer,1.);float layerIdx=max(0.,layer-1.);float floorLayerIdx=floor(layerIdx);vec4 aerialPerspectiveLayer0=textureLod(aerialPerspectiveLut,vec3(screenUV,floorLayerIdx),0.);vec4 aerialPerspectiveLayer1=textureLod(aerialPerspectiveLut,vec3(screenUV,floorLayerIdx+1.),0.);aerialPerspective=mix(aerialPerspectiveLayer0,aerialPerspectiveLayer1,layerIdx-floorLayerIdx);aerialPerspective.rgb*=atmosphereExposure;aerialPerspective=applyAerialPerspectiveSaturation(aerialPerspective);aerialPerspective=weight*applyAerialPerspectiveIntensity(aerialPerspective);aerialPerspective=applyAerialPerspectiveRadianceBias(aerialPerspective);return true;}\n#endif\nreturn false;}\n#if RENDER_TRANSMITTANCE\nvoid getTransmittanceParameters(vec2 uv,out float radius,out float cosAngleLightToZenith,out float distanceToAtmosphereEdge) {vec2 unit=uvToUnit(uv,TransmittanceLutDomainInUVSpace,TransmittanceLutHalfTexelSize);float distanceToHorizon=unit.y*horizonDistanceToAtmosphereEdge;float distanceToHorizonSquared=distanceToHorizon*distanceToHorizon;radius=sqrtClamped(distanceToHorizonSquared+planetRadiusSquared);float minDistanceToAtmosphereEdge=atmosphereRadius-radius;float maxDistanceToAtmosphereEdge=distanceToHorizon+horizonDistanceToAtmosphereEdge;distanceToAtmosphereEdge=minDistanceToAtmosphereEdge+unit.x*(maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);float distanceToAtmosphereEdgeSquared=distanceToAtmosphereEdge*distanceToAtmosphereEdge;cosAngleLightToZenith =\ndistanceToAtmosphereEdge<=0. ?\n1. :\n(horizonDistanceToAtmosphereEdgeSquared-distanceToAtmosphereEdgeSquared-distanceToHorizonSquared)/(2.*radius*distanceToAtmosphereEdge);cosAngleLightToZenith=clamp(cosAngleLightToZenith,-1.,1.);}\nvec4 renderTransmittance(vec2 uv) {float radius,cosAngleLightToZenith,distanceToAtmosphereEdgeAlongAngle;getTransmittanceParameters(uv,radius,cosAngleLightToZenith,distanceToAtmosphereEdgeAlongAngle);float sinAngleLightToZenith=sqrtClamped(1.-cosAngleLightToZenith*cosAngleLightToZenith);vec3 directionToLight=normalize(vec3(0.,cosAngleLightToZenith,sinAngleLightToZenith));vec3 transmittance=computeTransmittance(vec3(0.,radius,0.),directionToLight,distanceToAtmosphereEdgeAlongAngle,TransmittanceSampleCount);return vec4(transmittance,avg(transmittance));}\n#endif\n#if RENDER_MULTI_SCATTERING\nvec3 getSphereSample(float azimuth,float inclination,out float sinInclination) {sinInclination=sin(inclination);return vec3(sinInclination*sin(azimuth),cos(inclination),sinInclination*cos(azimuth));}\nconst float MultiScatteringInclinationSampleCount=8.;const float MultiScatteringAzimuthSampleCount=2.*MultiScatteringInclinationSampleCount;const float MultiScatteringLutSampleCount=64.;const float MultiScatteringAzimuthIterationAngle=TWO_PI/MultiScatteringAzimuthSampleCount;const float MultiScatteringInclinationIterationAngle=PI/MultiScatteringInclinationSampleCount;const float MultiScatteringAngleStepProduct=MultiScatteringAzimuthIterationAngle*MultiScatteringInclinationIterationAngle;\n#define inline\nvec4 renderMultiScattering(vec2 uv,sampler2D transmittanceLut) {vec2 unit=uvToUnit(uv,MultiScatteringLutDomainInUVSpace,MultiScatteringLutHalfTexelSize);float cosAngleLightToZenith=2.*unit.x-1.;float sinAngleLightToZenith=sqrtClamped(1.-cosAngleLightToZenith*cosAngleLightToZenith);vec3 directionToLight=normalize(vec3(0.,cosAngleLightToZenith,sinAngleLightToZenith));float rayOriginRadius=planetRadius+max(unit.y,0.001)*atmosphereThickness;vec3 rayOrigin=vec3(0.,rayOriginRadius,0.);vec3 inscattered=vec3(0.);vec3 multiScatteringTotal=vec3(0.);for (float i=0.5; i<MultiScatteringAzimuthSampleCount; ++i) {float azimuth=MultiScatteringAzimuthIterationAngle*i;for (float j=0.5; j<MultiScatteringInclinationSampleCount; ++j) {float inclination=MultiScatteringInclinationIterationAngle*j;float sinInclination;vec3 rayDirection=getSphereSample(azimuth,inclination,sinInclination);vec3 radiance;vec3 transmittance;vec3 multiScattering;integrateScatteredRadiance(\nfalse,\n1.,\ntransmittanceLut,\nrayOrigin,\nrayDirection,\ndirectionToLight,\n100000000.,\nMultiScatteringLutSampleCount,\n-1.,\nradiance,\ntransmittance,\nmultiScattering);float weight=RECIPROCAL_PI4*abs(sinInclination)*MultiScatteringAngleStepProduct;multiScatteringTotal+=multiScattering*weight;inscattered+=radiance*weight;}}\nvec3 multiScattering=inscattered/max(vec3(0.000001),vec3(1.)-multiScatteringTotal);return vec4(multiScattering,1.);}\n#endif\nfloat computeCosHorizonAngleFromZenith(float radius) {float sinAngleBetweenHorizonAndNadir=min(1.,planetRadius/radius);float cosHorizonAngleFromNadir=sqrt(1.-sinAngleBetweenHorizonAndNadir*sinAngleBetweenHorizonAndNadir);float cosHorizonAngleFromZenith=-cosHorizonAngleFromNadir;return cosHorizonAngleFromZenith;}\n#if RENDER_SKY_VIEW\nvoid getSkyViewParametersFromUV(\nfloat radius,\nvec2 uv,\nout float cosAngleBetweenViewAndZenith,\nout float cosAngleBetweenViewAndLightOnPlane) {vec2 unit=uvToUnit(uv,SkyViewLutDomainInUVSpace,SkyViewLutHalfTexelSize);float cosHorizonAngleFromZenith=computeCosHorizonAngleFromZenith(radius);if (unit.y<0.5) {float coord=2.*unit.y; \ncoord*=coord; \ncosAngleBetweenViewAndZenith=mix(-1.,cosHorizonAngleFromZenith,coord); } else {float coord=2.*unit.y-1.; \ncoord*=coord; \ncosAngleBetweenViewAndZenith=mix(cosHorizonAngleFromZenith,1.,coord); }\n{float coord=unit.x;cosAngleBetweenViewAndLightOnPlane=1.-2.*coord;}}\n#define inline\nvec4 renderSkyView(vec2 uv,sampler2D transmittanceLut,sampler2D multiScatteringLut) {float cosAngleBetweenViewAndZenith;float cosAngleBetweenViewAndLightOnPlane;getSkyViewParametersFromUV(clampedCameraRadius,uv,cosAngleBetweenViewAndZenith,cosAngleBetweenViewAndLightOnPlane);float sinAngleBetweenViewAndZenith=sqrtClamped(1.-cosAngleBetweenViewAndZenith*cosAngleBetweenViewAndZenith);float sinAngleBetweenViewAndLightOnPlane=sqrtClamped(1.-cosAngleBetweenViewAndLightOnPlane*cosAngleBetweenViewAndLightOnPlane);vec3 rayDirection =\nvec3(\nsinAngleBetweenViewAndZenith*cosAngleBetweenViewAndLightOnPlane,\ncosAngleBetweenViewAndZenith,\nsinAngleBetweenViewAndZenith*sinAngleBetweenViewAndLightOnPlane);bool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(\nvec3(0.,clampedCameraRadius,0.),\nclampedCameraRadius,\nvec3(0.,1.,0.),\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return vec4(0.);}\nvec3 transmittance;vec3 radiance;integrateScatteredRadiance(\nfalse,\natmosphereExposure*lightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLightRelativeToCameraGeocentricNormal,\n100000000.,\nSkyViewLutSampleCount,\n-1.,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);return vec4(radiance,transparency);}\n#endif\n#if RENDER_CAMERA_VOLUME\n#define inline\nvec4 renderCameraVolume(\nvec3 positionOnNearPlane,\nfloat layerIdx,\nsampler2D transmittanceLut,\nsampler2D multiScatteringLut) {vec4 result=vec4(0.);vec3 rayDirection=normalize(positionOnNearPlane);float layer=layerIdxToAerialPerspectiveLayer(layerIdx);float tMax=toAerialPerspectiveDepth(layer);float tMaxMax=tMax;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=clampedCameraPositionGlobal;if (clampedCameraRadius>=atmosphereRadius) {bool intersectsAtmosphere=false;moveToTopAtmosphere(\nclampedCameraPositionGlobal,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return result;}\nfloat distanceToAtmosphere=distance(clampedCameraPositionGlobal,cameraPositionGlobalClampedToTopOfAtmosphere);if (tMaxMax<distanceToAtmosphere) {return result;}\ntMaxMax=max(0.,tMaxMax-distanceToAtmosphere);}\nfloat sampleCount=min(SkyViewLutSampleCount,2.*layer+2.);vec3 transmittance;vec3 radiance;integrateScatteredRadiance(\ntrue,\nlightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLight,\ntMaxMax,\nsampleCount,\n-1.,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);result=vec4(radiance,transparency);return result;}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const atmosphereFunctions = { name, shader };\n"]}