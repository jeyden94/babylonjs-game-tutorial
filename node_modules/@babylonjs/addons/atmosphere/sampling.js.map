{"version":3,"file":"sampling.js","sourceRoot":"","sources":["../../../../dev/addons/src/atmosphere/sampling.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport { Clamp } from \"core/Maths/math.scalar.functions\";\r\nimport type { IColor4Like } from \"core/Maths/math.like\";\r\n\r\nconst MakeTempColor4Like = (): IColor4Like => {\r\n    return {\r\n        r: Number.NaN,\r\n        g: Number.NaN,\r\n        b: Number.NaN,\r\n        a: Number.NaN,\r\n    };\r\n};\r\n\r\nconst TmpColor1 = MakeTempColor4Like();\r\nconst TmpColor2 = MakeTempColor4Like();\r\nconst TmpColor3 = MakeTempColor4Like();\r\nconst TmpColor4 = MakeTempColor4Like();\r\n\r\n/**\r\n * Samples the texture data at the given uv coordinate using bilinear interpolation.\r\n * Note this will not match GPU sampling behavior exactly.\r\n * Currently assumes clamping behavior.\r\n * @param u - The u coordinate to sample.\r\n * @param v - The v coordinate to sample.\r\n * @param widthPx - The width of the texture in texels.\r\n * @param heightPx - The height of the texture in texels.\r\n * @param data - The texture data to sample.\r\n * @param result - The color to store the sample.\r\n * @param normalizeFunc - The function to normalize the texel values. Default is to divide by 255.\r\n * @returns The result color.\r\n */\r\nexport function Sample2DRgbaToRef<T extends IColor4Like>(\r\n    u: number,\r\n    v: number,\r\n    widthPx: number,\r\n    heightPx: number,\r\n    data: Uint8Array | Uint16Array | Float32Array,\r\n    result: T,\r\n    normalizeFunc = (value: number) => value / 255.0\r\n): T {\r\n    if (widthPx <= 0 || heightPx <= 0) {\r\n        throw new Error(\"Sample2DRgbaToRef: widthPx and heightPx must be positive.\");\r\n    }\r\n\r\n    const expectedLength = widthPx * heightPx * 4;\r\n    if (data.length < expectedLength) {\r\n        throw new Error(`Sample2DRgbaToRef: data length (${data.length}) is less than required (${expectedLength}).`);\r\n    }\r\n\r\n    // Default to clamping behavior, but could support others.\r\n    u = Clamp(u);\r\n    v = Clamp(v);\r\n\r\n    // Compute 4 nearest neighbor texels.\r\n    const fractionalTexelX = Math.max(u * widthPx - 0.5, 0);\r\n    const fractionalTexelY = Math.max(v * heightPx - 0.5, 0);\r\n    const xLeft = Math.floor(fractionalTexelX);\r\n    const xRight = Math.min(xLeft + 1, widthPx - 1);\r\n    const yBottom = Math.floor(fractionalTexelY);\r\n    const yTop = Math.min(yBottom + 1, heightPx - 1);\r\n\r\n    // Sample nearest neighbor texels.\r\n    const lowerLeftColor = TexelFetch2DRgbaToRef(xLeft, yBottom, widthPx, heightPx, data, TmpColor1, normalizeFunc);\r\n    const upperLeftColor = TexelFetch2DRgbaToRef(xLeft, yTop, widthPx, heightPx, data, TmpColor2, normalizeFunc);\r\n    const lowerRightColor = TexelFetch2DRgbaToRef(xRight, yBottom, widthPx, heightPx, data, TmpColor3, normalizeFunc);\r\n    const upperRightColor = TexelFetch2DRgbaToRef(xRight, yTop, widthPx, heightPx, data, TmpColor4, normalizeFunc);\r\n\r\n    // Compute weights.\r\n    const tX = fractionalTexelX - xLeft;\r\n    const tY = fractionalTexelY - yBottom;\r\n    const oneMinusTX = 1.0 - tX;\r\n    const oneMinusTY = 1.0 - tY;\r\n    const w0 = oneMinusTX * oneMinusTY;\r\n    const w1 = tX * oneMinusTY;\r\n    const w2 = oneMinusTX * tY;\r\n    const w3 = tX * tY;\r\n\r\n    // Compute the result.\r\n    result.r = lowerLeftColor.r * w0 + lowerRightColor.r * w1 + upperLeftColor.r * w2 + upperRightColor.r * w3;\r\n    result.g = lowerLeftColor.g * w0 + lowerRightColor.g * w1 + upperLeftColor.g * w2 + upperRightColor.g * w3;\r\n    result.b = lowerLeftColor.b * w0 + lowerRightColor.b * w1 + upperLeftColor.b * w2 + upperRightColor.b * w3;\r\n    result.a = lowerLeftColor.a * w0 + lowerRightColor.a * w1 + upperLeftColor.a * w2 + upperRightColor.a * w3;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Fetches a texel from a 2D texture and stores the result in the given color.\r\n * @param x - The x coordinate in texels.\r\n * @param y - The y coordinate in texels.\r\n * @param width - The width of the texture in texels.\r\n * @param height - The height of the texture in texels.\r\n * @param data - The texture data to sample from.\r\n * @param result - The color to store the sampled color in.\r\n * @param normalizeFunc - The function to normalize the texel values. Default is to divide by 255.\r\n * @returns The result color.\r\n */\r\nconst TexelFetch2DRgbaToRef = <T extends IColor4Like>(\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number,\r\n    data: Uint8Array | Uint16Array | Float32Array,\r\n    result: T,\r\n    normalizeFunc = (value: number) => value / 255.0\r\n): T => {\r\n    const clampedTexelX = Clamp(x, 0, width - 1);\r\n    const clampedTexelY = Clamp(y, 0, height - 1);\r\n    const index = 4 * (clampedTexelY * width + clampedTexelX);\r\n    result.r = normalizeFunc(data[index]);\r\n    result.g = normalizeFunc(data[index + 1]);\r\n    result.b = normalizeFunc(data[index + 2]);\r\n    result.a = normalizeFunc(data[index + 3]);\r\n    return result;\r\n};\r\n"]}