import type { Atmosphere } from "./atmosphere.js";
import type { BaseTexture } from "@babylonjs/core/Materials/Textures/baseTexture.js";
import type { Material } from "@babylonjs/core/Materials/material.js";
import { MaterialDefines } from "@babylonjs/core/Materials/materialDefines.js";
import { MaterialPluginBase } from "@babylonjs/core/Materials/materialPluginBase.js";
import type { Nullable } from "@babylonjs/core/types.js";
import type { UniformBuffer } from "@babylonjs/core/Materials/uniformBuffer.js";
declare class AtmospherePBRMaterialDefines extends MaterialDefines {
    USE_AERIAL_PERSPECTIVE_LUT: boolean;
    APPLY_AERIAL_PERSPECTIVE_INTENSITY: boolean;
    APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS: boolean;
    SAMPLE_TRANSMITTANCE_LUT: boolean;
    EXCLUDE_RAY_MARCHING_FUNCTIONS: boolean;
    /**
     * Constructs the {@link AtmospherePBRMaterialDefines}.
     * @param useAerialPerspectiveLut - Whether to use the aerial perspective LUT.
     */
    constructor(useAerialPerspectiveLut: boolean);
}
/**
 * Adds shading logic to a PBRMaterial that provides radiance, diffuse sky irradiance, and aerial perspective from the atmosphere.
 */
export declare class AtmospherePBRMaterialPlugin extends MaterialPluginBase {
    private readonly _atmosphere;
    private readonly _isAerialPerspectiveEnabled;
    /**
     * Constructs the {@link AtmospherePBRMaterialPlugin}.
     * @param material - The material to apply the plugin to.
     * @param _atmosphere - The atmosphere to use for shading.
     * @param _isAerialPerspectiveEnabled - Whether to apply aerial perspective.
     */
    constructor(material: Material, _atmosphere: Atmosphere, _isAerialPerspectiveEnabled?: boolean);
    /**
     * @override
     */
    getUniformBuffersNames(_ubos: string[]): void;
    /**
     * @override
     */
    getUniforms(): {
        ubo: {
            name: string;
            size: number;
            type: string;
        }[];
        fragment: string;
        externalUniforms: string[];
    };
    /**
     * @override
     */
    isReadyForSubMesh(): boolean;
    /**
     * @override
     */
    getActiveTextures(_activeTextures: BaseTexture[]): void;
    /**
     * @override
     */
    bindForSubMesh(uniformBuffer: UniformBuffer): void;
    /**
     * @override
     */
    prepareDefines(defines: AtmospherePBRMaterialDefines): void;
    /**
     * @override
     */
    getSamplers(samplers: string[]): void;
    /**
     * @override
     */
    getCustomCode(shaderType: string): Nullable<Record<string, string>>;
}
export {};
