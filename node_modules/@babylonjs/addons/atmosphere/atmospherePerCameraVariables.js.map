{"version":3,"file":"atmospherePerCameraVariables.js","sourceRoot":"","sources":["../../../../dev/addons/src/atmosphere/atmospherePerCameraVariables.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAIlC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,6CAA+B;AAClE,OAAO,EAAE,GAAG,EAAE,4CAA8B;AAC5C,OAAO,EAAE,UAAU,EAAE,uDAAyC;AAE9D,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;AAExD;;GAEG;AACH,MAAM,OAAO,4BAA4B;IAAzC;QACY,mDAA8C,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QACnE,sDAAiD,GAAG,OAAO,CAAC,EAAE,EAAE,CAAC;QACjE,2BAAsB,GAAG,CAAC,CAAC;QAC3B,kBAAa,GAAG,CAAC,CAAC;QAClB,yBAAoB,GAAG,CAAC,CAAC;QACzB,kBAAa,GAAG,CAAC,CAAC;QAClB,yBAAoB,GAAG,CAAC,CAAC;QACzB,0BAAqB,GAAG,IAAI,OAAO,EAAE,CAAC;QACtC,iCAA4B,GAAG,IAAI,OAAO,EAAE,CAAC;QAC7C,qCAAgC,GAAG,CAAC,CAAC;QACrC,8CAAyC,GAAG,CAAC,CAAC;QAC9C,4BAAuB,GAAG,OAAO,CAAC,EAAE,EAAE,CAAC;QACvC,mBAAc,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QAChC,qBAAgB,GAAG,CAAC,CAAC;QACrB,oBAAe,GAAG,IAAI,OAAO,EAAE,CAAC;QAChC,cAAS,GAAG,IAAI,OAAO,EAAE,CAAC;QAC1B,oBAAe,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QACpC,0BAAqB,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QAC1C,yCAAoC,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QACzD,6BAAwB,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;IAiMzD,CAAC;IA/LG;;;OAGG;IACH,IAAW,6CAA6C;QACpD,OAAO,IAAI,CAAC,8CAA8C,CAAC;IAC/D,CAAC;IAED;;OAEG;IACH,IAAW,gDAAgD;QACvD,OAAO,IAAI,CAAC,iDAAiD,CAAC;IAClE,CAAC;IAED;;OAEG;IACH,IAAW,qBAAqB;QAC5B,OAAO,IAAI,CAAC,sBAAsB,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,IAAW,YAAY;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,IAAW,mBAAmB;QAC1B,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,IAAW,YAAY;QACnB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,IAAW,mBAAmB;QAC1B,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACrC,CAAC;IAED;;;;;;OAMG;IACH,IAAW,oBAAoB;QAC3B,OAAO,IAAI,CAAC,qBAAqB,CAAC;IACtC,CAAC;IAED;;;OAGG;IACH,IAAW,2BAA2B;QAClC,OAAO,IAAI,CAAC,4BAA4B,CAAC;IAC7C,CAAC;IAED;;OAEG;IACH,IAAW,+BAA+B;QACtC,OAAO,IAAI,CAAC,gCAAgC,CAAC;IACjD,CAAC;IAED;;OAEG;IACH,IAAW,wCAAwC;QAC/C,OAAO,IAAI,CAAC,yCAAyC,CAAC;IAC1D,CAAC;IAED;;;OAGG;IACH,IAAW,sBAAsB;QAC7B,OAAO,IAAI,CAAC,uBAAuB,CAAC;IACxC,CAAC;IAED;;OAEG;IACH,IAAW,aAAa;QACpB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAED;;OAEG;IACH,IAAW,eAAe;QACtB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED;;OAEG;IACH,IAAW,cAAc;QACrB,OAAO,IAAI,CAAC,eAAe,CAAC;IAChC,CAAC;IAED;;OAEG;IACH,IAAW,QAAQ;QACf,OAAO,IAAI,CAAC,SAAS,CAAC;IAC1B,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,MAAc,EAAE,YAAoB,EAAE,sBAA8B,EAAE,gBAAwB,EAAE,gBAA8B,EAAE,YAAoB;QAC9J,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,IAAI,CAAC;QACpC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,kBAAkB,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAE9E,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;QACjC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,CAAC,cAAc,EAAE,EAAE,MAAM,CAAC,eAAe,EAAE,CAAC,CAAC;QAE3F,wGAAwG;QACxG,MAAM,UAAU,GAAG,MAAM,CAAC,aAAa,EAAE,CAAC;QAC1C,MAAM,gBAAgB,GAAG,MAAM,CAAC,mBAAmB,EAAE,CAAC;QACtD,MAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC;QAC5C,MAAM,oBAAoB,GAAG,IAAI,CAAC,qBAAqB,CAAC;QACxD,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE,CAAC;YACvF,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACpC,cAAc,CAAC,cAAc,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;YACpD,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,oCAAoC,CAAC,CAAC;YAEtE,oBAAoB,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;YAChD,oBAAoB,CAAC,WAAW,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAChE,IAAI,CAAC,wBAAwB,CAAC,aAAa,CAAC,IAAI,CAAC,oCAAoC,EAAE,IAAI,CAAC,8CAA8C,CAAC,CAAC;QAChJ,CAAC;QAED,iEAAiE;QACjE,MAAM,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,sBAAsB;QAEvJ,yGAAyG;QACzG,IAAI,KAAK,CAAC,kBAAkB,EAAE,CAAC;YAC3B,mFAAmF;YACnF,2DAA2D;YAC3D,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;YAClE,IAAI,CAAC,uBAAuB,CAAC,gBAAgB,CAAC,YAAY,EAAE,oBAAoB,CAAC,CAAC;QACtF,CAAC;aAAM,CAAC;YACJ,mFAAmF;YACnF,qFAAqF;YACrF,oBAAoB,CAAC,CAAC,IAAI,YAAY,GAAG,YAAY,CAAC;YACtD,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;QACtE,CAAC;QAED,IAAI,CAAC,aAAa,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,CAAC,8BAA8B;QAClF,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC,CAAC,8BAA8B;QAEtF,+BAA+B;QAC/B,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC;QAC/C,IAAI,IAAI,CAAC,oBAAoB,GAAG,sBAAsB,EAAE,CAAC;YACrD,IAAI,CAAC,oBAAoB,GAAG,sBAAsB,CAAC;YACnD,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,sBAAsB,EAAE,IAAI,CAAC,4BAA4B,CAAC,CAAC;QACvG,CAAC;aAAM,CAAC;YACJ,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,oBAAoB,CAAC,CAAC;QACrE,CAAC;QAED,IAAI,CAAC,gCAAgC,GAAG,gCAAgC,CAAC,YAAY,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QAClH,IAAI,CAAC,yCAAyC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,gBAAgB,GAAG,IAAI,CAAC,oBAAoB,CAAC,CAAC;QAC7G,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,GAAG,YAAY,CAAC;QAErE,iFAAiF;QACjF,CAAC;YACG,IAAI,CAAC,sBAAsB,GAAG,UAAU,CAAC,gBAAgB,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC;YACzF,MAAM,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;YACtH,IAAI,CAAC,iDAAiD,CAAC,cAAc,CAAC,mBAAmB,EAAE,IAAI,CAAC,sBAAsB,EAAE,GAAG,CAAC,CAAC;YAC7H,IAAI,CAAC,iDAAiD,CAAC,SAAS,EAAE,CAAC;QACvE,CAAC;IACL,CAAC;CACJ;AAED,MAAM,gCAAgC,GAAG,CAAC,YAAoB,EAAE,MAAc,EAAU,EAAE;IACtF,MAAM,wBAAwB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,YAAY,GAAG,MAAM,CAAC,CAAC;IACpE,MAAM,wBAAwB,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,wBAAwB,GAAG,wBAAwB,CAAC,CAAC;IACpG,MAAM,yBAAyB,GAAG,CAAC,wBAAwB,CAAC;IAC5D,OAAO,yBAAyB,CAAC;AACrC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like } from \"core/Maths/math.like\";\r\nimport { Matrix, Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Ray } from \"core/Culling/ray.core\";\r\nimport { Vector3Dot } from \"core/Maths/math.vector.functions\";\r\n\r\nconst TempRay = new Ray(Vector3.Zero(), Vector3.Zero());\r\n\r\n/**\r\n * Variables that are used to render the atmosphere and are computed per-camera.\r\n */\r\nexport class AtmospherePerCameraVariables {\r\n    private _inverseViewProjectionMatrixWithoutTranslation = Matrix.Identity();\r\n    private _directionToLightRelativeToCameraGeocentricNormal = Vector3.Up();\r\n    private _cosAngleLightToZenith = 0;\r\n    private _cameraRadius = 0;\r\n    private _clampedCameraRadius = 0;\r\n    private _cameraHeight = 0;\r\n    private _clampedCameraHeight = 0;\r\n    private _cameraPositionGlobal = new Vector3();\r\n    private _clampedCameraPositionGlobal = new Vector3();\r\n    private _cosCameraHorizonAngleFromZenith = 0;\r\n    private _sinCameraAtmosphereHorizonAngleFromNadir = 0;\r\n    private _cameraGeocentricNormal = Vector3.Up();\r\n    private _cameraForward = Vector3.Down();\r\n    private _cameraNearPlane = 0;\r\n    private _cameraPosition = new Vector3();\r\n    private _viewport = new Vector4();\r\n    private _lastViewMatrix = Matrix.Identity();\r\n    private _lastProjectionMatrix = Matrix.Identity();\r\n    private _inverseViewMatrixWithoutTranslation = Matrix.Identity();\r\n    private _inverseProjectionMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * The inverse view projection matrix is used to unproject rays.\r\n     * To avoid precision issues, the translation part of the matrix has been removed.\r\n     */\r\n    public get inverseViewProjectionMatrixWithoutTranslation(): IMatrixLike {\r\n        return this._inverseViewProjectionMatrixWithoutTranslation;\r\n    }\r\n\r\n    /**\r\n     * The direction to the light relative to the geocentric normal under the camera.\r\n     */\r\n    public get directionToLightRelativeToCameraGeocentricNormal(): IVector3Like {\r\n        return this._directionToLightRelativeToCameraGeocentricNormal;\r\n    }\r\n\r\n    /**\r\n     * The cosine of the angle between the light direction and zenith.\r\n     */\r\n    public get cosAngleLightToZenith(): number {\r\n        return this._cosAngleLightToZenith;\r\n    }\r\n\r\n    /**\r\n     * The distance from the camera to the planet origin in kilometers.\r\n     */\r\n    public get cameraRadius(): number {\r\n        return this._cameraRadius;\r\n    }\r\n\r\n    /**\r\n     * The distance from the camera to the planet origin, clamped to the planet radius offset, in kilometers.\r\n     */\r\n    public get clampedCameraRadius(): number {\r\n        return this._clampedCameraRadius;\r\n    }\r\n\r\n    /**\r\n     * The height of the camera above the planet surface in kilometers.\r\n     */\r\n    public get cameraHeight(): number {\r\n        return this._cameraHeight;\r\n    }\r\n\r\n    /**\r\n     * The height of the camera above the planet surface, clamped to the planet radius offset, in kilometers.\r\n     */\r\n    public get clampedCameraHeight(): number {\r\n        return this._clampedCameraHeight;\r\n    }\r\n\r\n    /**\r\n     * The camera position in global space kilometers.\r\n     *\r\n     * The behavior of this value depends on whether floating origin mode is enabled:\r\n     * - If floating origin mode is enabled, this is simply the camera's global position scaled to kilometers. The atmosphere's origin height is used to offset the camera position along its geocentric normal.\r\n     * - If floating origin mode is disabled, the camera's y position is offset by the planet radius plus any origin height.\r\n     */\r\n    public get cameraPositionGlobal(): IVector3Like {\r\n        return this._cameraPositionGlobal;\r\n    }\r\n\r\n    /**\r\n     * The camera position, clamped to the planet radius offset, in global space kilometers.\r\n     * See {@link cameraPositionGlobal} for details on how the value is computed.\r\n     */\r\n    public get clampedCameraPositionGlobal(): IVector3Like {\r\n        return this._clampedCameraPositionGlobal;\r\n    }\r\n\r\n    /**\r\n     * The cosine of the angle from the zenith to the horizon of the planet, measured from the camera position.\r\n     */\r\n    public get cosCameraHorizonAngleFromZenith(): number {\r\n        return this._cosCameraHorizonAngleFromZenith;\r\n    }\r\n\r\n    /**\r\n     * The sine of the angle from the nadir to the horizon of the atmosphere, measured from the camera position.\r\n     */\r\n    public get sinCameraAtmosphereHorizonAngleFromNadir(): number {\r\n        return this._sinCameraAtmosphereHorizonAngleFromNadir;\r\n    }\r\n\r\n    /**\r\n     * The geocentric normal of the camera in global space i.e., the normalization of {@link cameraPositionGlobal}.\r\n     * Note the behavior of this value depends on whether floating origin mode is enabled. See {@link cameraPositionGlobal} for details.\r\n     */\r\n    public get cameraGeocentricNormal(): IVector3Like {\r\n        return this._cameraGeocentricNormal;\r\n    }\r\n\r\n    /**\r\n     * The camera's forward direction in world space.\r\n     */\r\n    public get cameraForward(): IVector3Like {\r\n        return this._cameraForward;\r\n    }\r\n\r\n    /**\r\n     * The distance to the near plane of the camera.\r\n     */\r\n    public get cameraNearPlane(): number {\r\n        return this._cameraNearPlane;\r\n    }\r\n\r\n    /**\r\n     * The camera's position in world space.\r\n     */\r\n    public get cameraPosition(): IVector3Like {\r\n        return this._cameraPosition;\r\n    }\r\n\r\n    /**\r\n     * The viewport for the camera.\r\n     */\r\n    public get viewport(): IVector4Like {\r\n        return this._viewport;\r\n    }\r\n\r\n    /**\r\n     * Updates the variables.\r\n     * @param camera - The camera to update the variables for.\r\n     * @param planetRadius - The radius of the planet in kilometers.\r\n     * @param planetRadiusWithOffset - The radius of the planet with the offset in kilometers.\r\n     * @param atmosphereRadius - The radius of the atmosphere in kilometers.\r\n     * @param directionToLight - The direction to the light in world space.\r\n     * @param originHeight - The height of the origin (distance from planet's surface) in kilometers.\r\n     */\r\n    public update(camera: Camera, planetRadius: number, planetRadiusWithOffset: number, atmosphereRadius: number, directionToLight: IVector3Like, originHeight: number): void {\r\n        this._cameraNearPlane = camera.minZ;\r\n        this._cameraForward.copyFrom(camera.getForwardRayToRef(TempRay, 1).direction);\r\n\r\n        const scene = camera.getScene();\r\n        const engine = scene.getEngine();\r\n        this._viewport.copyFromFloats(0.0, 0.0, engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Compute inverse view projection matrix, but remove the translational component to increase precision.\r\n        const viewMatrix = camera.getViewMatrix();\r\n        const projectionMatrix = camera.getProjectionMatrix();\r\n        const lastViewMatrix = this._lastViewMatrix;\r\n        const lastProjectionMatrix = this._lastProjectionMatrix;\r\n        if (!lastViewMatrix.equals(viewMatrix) || !lastProjectionMatrix.equals(projectionMatrix)) {\r\n            lastViewMatrix.copyFrom(viewMatrix);\r\n            lastViewMatrix.setTranslation(Vector3.ZeroReadOnly);\r\n            lastViewMatrix.invertToRef(this._inverseViewMatrixWithoutTranslation);\r\n\r\n            lastProjectionMatrix.copyFrom(projectionMatrix);\r\n            lastProjectionMatrix.invertToRef(this._inverseProjectionMatrix);\r\n            this._inverseProjectionMatrix.multiplyToRef(this._inverseViewMatrixWithoutTranslation, this._inverseViewProjectionMatrixWithoutTranslation);\r\n        }\r\n\r\n        // Compute the global space position of the camera in kilometers.\r\n        const cameraPositionGlobal = this._cameraPosition.copyFrom(camera.globalPosition).scaleToRef(0.001, this._cameraPositionGlobal); // scale to kilometers\r\n\r\n        // Apply the origin height to the camera position, and in doing so, compute the camera geocentric normal.\r\n        if (scene.floatingOriginMode) {\r\n            // When in floating origin mode, assume world space origin is at the planet center.\r\n            // Therefore \"up\" is away from the planet center (0, 0, 0).\r\n            cameraPositionGlobal.normalizeToRef(this._cameraGeocentricNormal);\r\n            this._cameraGeocentricNormal.scaleAndAddToRef(originHeight, cameraPositionGlobal);\r\n        } else {\r\n            // If not in floating origin mode, offset the camera position by the origin height.\r\n            // Assume the origin is directly above the planet surface along the up axis (y axis).\r\n            cameraPositionGlobal.y += planetRadius + originHeight;\r\n            cameraPositionGlobal.normalizeToRef(this._cameraGeocentricNormal);\r\n        }\r\n\r\n        this._cameraRadius = cameraPositionGlobal.length(); // distance from planet center\r\n        this._cameraHeight = this._cameraRadius - planetRadius; // height above planet surface\r\n\r\n        // Clamp the camera parameters.\r\n        this._clampedCameraRadius = this._cameraRadius;\r\n        if (this._clampedCameraRadius < planetRadiusWithOffset) {\r\n            this._clampedCameraRadius = planetRadiusWithOffset;\r\n            this._cameraGeocentricNormal.scaleToRef(planetRadiusWithOffset, this._clampedCameraPositionGlobal);\r\n        } else {\r\n            this._clampedCameraPositionGlobal.copyFrom(cameraPositionGlobal);\r\n        }\r\n\r\n        this._cosCameraHorizonAngleFromZenith = ComputeCosHorizonAngleFromZenith(planetRadius, this._clampedCameraRadius);\r\n        this._sinCameraAtmosphereHorizonAngleFromNadir = Math.min(1.0, atmosphereRadius / this._clampedCameraRadius);\r\n        this._clampedCameraHeight = this._clampedCameraRadius - planetRadius;\r\n\r\n        // Compute the direction to the light relative to the camera's geocentric normal.\r\n        {\r\n            this._cosAngleLightToZenith = Vector3Dot(directionToLight, this._cameraGeocentricNormal);\r\n            const lightZenithSinAngle = Math.sqrt(Math.max(0.0, 1.0 - this._cosAngleLightToZenith * this._cosAngleLightToZenith));\r\n            this._directionToLightRelativeToCameraGeocentricNormal.copyFromFloats(lightZenithSinAngle, this._cosAngleLightToZenith, 0.0);\r\n            this._directionToLightRelativeToCameraGeocentricNormal.normalize();\r\n        }\r\n    }\r\n}\r\n\r\nconst ComputeCosHorizonAngleFromZenith = (planetRadius: number, radius: number): number => {\r\n    const sinHorizonAngleFromNadir = Math.min(1, planetRadius / radius);\r\n    const cosHorizonAngleFromNadir = Math.sqrt(1 - sinHorizonAngleFromNadir * sinHorizonAngleFromNadir);\r\n    const cosHorizonAngleFromZenith = -cosHorizonAngleFromNadir;\r\n    return cosHorizonAngleFromZenith;\r\n};\r\n"]}