import { Buffer } from "@babylonjs/core/Buffers/buffer.js";
import { Constants } from "@babylonjs/core/Engines/constants.js";
import { DrawWrapper } from "@babylonjs/core/Materials/drawWrapper.js";
import { SdfTextParagraph } from "./sdf/paragraph.js";
import { ThinMatrix } from "@babylonjs/core/Maths/ThinMaths/thinMath.matrix.js";
import { CopyMatrixToArray, CopyMatrixToRef, IdentityMatrixToRef, MultiplyMatricesToRef, ScalingMatrixToRef, TranslationMatrixToRef, } from "@babylonjs/core/Maths/ThinMaths/thinMath.matrix.functions.js";
/**
 * Class used to render text using MSDF (Multi-channel Signed Distance Field) technique
 * Thanks a lot to the work of Bhushan_Wagh and zb_sj for their amazing work on MSDF for Babylon.js
 * #6RLCWP#16
 * Star wars scroller: #6RLCWP#29
 * With metrics: #6RLCWP#35
 * Thickness: #IABMEZ#3
 * Solar system: #9YCDYC#9
 * Stroke: #6RLCWP#37
 */
export class TextRenderer {
    /**
     * Gets or sets the parent of the text renderer
     */
    get parent() {
        return this._parent;
    }
    set parent(value) {
        this._parent = value;
    }
    /**
     * Gets or sets the transform matrix of the text renderer
     * It will be applied in that order:
     * parent x transform x paragraph world
     */
    get transformMatrix() {
        return this._transformMatrix;
    }
    set transformMatrix(value) {
        this._transformMatrix = value;
    }
    /**
     * Gets the number of characters in the text renderer
     */
    get characterCount() {
        return this._charMatrices.length / 16;
    }
    constructor(engine, shaderLanguage = 0 /* ShaderLanguage.GLSL */, font) {
        this._useVAO = false;
        this._vertexBuffers = {};
        this._charMatrices = new Array();
        this._charUvs = new Array();
        this._isDirty = true;
        this._baseLine = 0;
        // Cache
        this._scalingMatrix = new ThinMatrix();
        this._fontScaleMatrix = new ThinMatrix();
        this._offsetMatrix = new ThinMatrix();
        this._translationMatrix = new ThinMatrix();
        this._baseMatrix = new ThinMatrix();
        this._scaledMatrix = new ThinMatrix();
        this._localMatrix = new ThinMatrix();
        this._finalMatrix = new ThinMatrix();
        this._lineMatrix = new ThinMatrix();
        this._parentWorldMatrix = new ThinMatrix();
        /**
         * Gets or sets the color of the text
         */
        this.color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
        /**
         * Gets or sets the color of the stroke around the text
         */
        this.strokeColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
        /**
         * Gets or sets the width of the stroke around the text (inset)
         */
        this.strokeInsetWidth = 0;
        /**
         * Gets or sets the width of the stroke around the text (outset)
         */
        this.strokeOutsetWidth = 0;
        /**
         * Gets or sets the thickness of the text (0 means as defined in the font)
         * Value must be between -0.5 and 0.5
         */
        this.thicknessControl = 0;
        this._parent = null;
        this._transformMatrix = new ThinMatrix();
        /**
         * Gets or sets if the text is billboarded
         */
        this.isBillboard = false;
        /**
         * Gets or sets if the text is screen projected
         * This will work only if the text is billboarded
         */
        this.isBillboardScreenProjected = false;
        /**
         * Gets or sets if the text renderer should ignore the depth buffer
         * Default is false
         */
        this.ignoreDepthBuffer = false;
        this._engine = engine;
        this._shaderLanguage = shaderLanguage;
        this._font = font;
        this._baseLine = font._font.common.lineHeight * font.scale;
        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;
        // Main vertex buffer
        const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
        this._vertexBuffers["offsets"] = this._spriteBuffer.createVertexBuffer("offsets", 0, 2);
        // Instances
        this._resizeBuffers(128);
    }
    _resizeBuffers(capacity) {
        if (this._worldBuffer) {
            this._worldBuffer.dispose();
            this._worldBuffer = null;
        }
        if (this._uvBuffer) {
            this._uvBuffer.dispose();
            this._uvBuffer = null;
        }
        this._worldBuffer = new Buffer(this._engine, new Float32Array(capacity * 16), true, 16);
        this._vertexBuffers["world0"] = this._worldBuffer.createVertexBuffer("world0", 0, 4, 16, true);
        this._vertexBuffers["world1"] = this._worldBuffer.createVertexBuffer("world1", 4, 4, 16, true);
        this._vertexBuffers["world2"] = this._worldBuffer.createVertexBuffer("world2", 8, 4, 16, true);
        this._vertexBuffers["world3"] = this._worldBuffer.createVertexBuffer("world3", 12, 4, 16, true);
        this._uvBuffer = new Buffer(this._engine, new Float32Array(capacity * 4), true, 4);
        this._vertexBuffers["uvs"] = this._uvBuffer.createVertexBuffer("uvs", 0, 4, 4, true);
    }
    _setShaders(vertex, fragment) {
        this._drawWrapperBase?.dispose();
        this._drawWrapperBase = new DrawWrapper(this._engine);
        if (this._drawWrapperBase.drawContext) {
            this._drawWrapperBase.drawContext.useInstancing = true;
        }
        const defines = "";
        this._drawWrapperBase.effect = this._engine.createEffect({
            vertexSource: vertex,
            fragmentSource: fragment,
        }, ["offsets", "world0", "world1", "world2", "world3", "uvs"], ["parentWorld", "view", "projection", "uColor", "thickness", "uStrokeColor", "uStrokeInsetWidth", "uStrokeOutsetWidth", "mode", "transform"], ["fontAtlas"], defines, undefined, undefined, undefined, undefined, this._shaderLanguage);
        this._drawWrapperBase.effect._refCount++;
    }
    /**
     * Add a paragraph of text to the renderer
     * @param text define the text to add
     * @param options define the options to use for the paragraph (optional)
     * @param worldMatrix define the world matrix to use for the paragraph (optional)
     */
    addParagraph(text, options, worldMatrix) {
        const paragraph = new SdfTextParagraph(text, this._font, options);
        const fontScale = this._font.scale;
        const texWidth = this._font._font.common.scaleW;
        const texHeight = this._font._font.common.scaleH;
        const glyphs = paragraph.glyphs.filter((g) => g.char.page >= 0);
        let worldMatrixToUse = worldMatrix;
        if (!worldMatrixToUse) {
            const lineHeight = paragraph.lineHeight * fontScale;
            const lineOffset = (paragraph.lines.length * lineHeight) / 2;
            TranslationMatrixToRef(0, this._baseLine - lineOffset, 0, this._lineMatrix);
            worldMatrixToUse = this._lineMatrix;
        }
        ScalingMatrixToRef(fontScale, fontScale, 1.0, this._fontScaleMatrix);
        TranslationMatrixToRef(0.5, -0.5, 0, this._offsetMatrix);
        const charsUvsBase = this._charUvs.length;
        const matricesBase = this._charMatrices.length;
        glyphs.forEach((g, i) => {
            this._charUvs[charsUvsBase + i * 4 + 0] = g.char.x / texWidth;
            this._charUvs[charsUvsBase + i * 4 + 1] = g.char.y / texHeight;
            this._charUvs[charsUvsBase + i * 4 + 2] = g.char.width / texWidth;
            this._charUvs[charsUvsBase + i * 4 + 3] = g.char.height / texHeight;
            const x = g.x + g.char.xoffset;
            const y = 1.0 - (g.y + g.char.yoffset);
            ScalingMatrixToRef(g.char.width, g.char.height, 1.0, this._scalingMatrix);
            MultiplyMatricesToRef(this._offsetMatrix, this._scalingMatrix, this._baseMatrix);
            TranslationMatrixToRef(x * fontScale, y * fontScale, 0.0, this._translationMatrix);
            MultiplyMatricesToRef(this._baseMatrix, this._fontScaleMatrix, this._scaledMatrix);
            MultiplyMatricesToRef(this._scaledMatrix, this._translationMatrix, this._localMatrix);
            MultiplyMatricesToRef(this._localMatrix, worldMatrixToUse, this._finalMatrix);
            CopyMatrixToArray(this._finalMatrix, this._charMatrices, matricesBase + i * 16);
        });
        this._isDirty = true;
        this._baseLine -= paragraph.lineHeight * fontScale * paragraph.lines.length;
    }
    /**
     * Render the text using the provided view and projection matrices
     * @param viewMatrix define the view matrix to use
     * @param projectionMatrix define the projection matrix to use
     */
    render(viewMatrix, projectionMatrix) {
        const drawWrapper = this._drawWrapperBase;
        const effect = drawWrapper.effect;
        // Check
        if (!effect.isReady()) {
            return;
        }
        const engine = this._engine;
        engine.setState(false);
        engine.enableEffect(drawWrapper);
        if (this.ignoreDepthBuffer) {
            engine.setDepthBuffer(false);
        }
        if (this._parent) {
            CopyMatrixToRef(this._parent.getWorldMatrix(), this._parentWorldMatrix);
        }
        else {
            IdentityMatrixToRef(this._parentWorldMatrix);
        }
        effect.setInt("mode", this.isBillboard ? (this.isBillboardScreenProjected ? 2 : 1) : 0);
        effect.setMatrix("parentWorld", this._parentWorldMatrix);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", projectionMatrix);
        effect.setMatrix("transform", this.transformMatrix);
        // Texture
        effect.setTexture("fontAtlas", this._font.textures[0]);
        effect.setDirectColor4("uColor", this.color);
        effect.setDirectColor4("uStrokeColor", this.strokeColor);
        effect.setFloat("thickness", this.thicknessControl * 0.9);
        effect.setFloat("uStrokeInsetWidth", this.strokeInsetWidth);
        effect.setFloat("uStrokeOutsetWidth", this.strokeOutsetWidth);
        const instanceCount = this._charMatrices.length / 16;
        // Need update?
        if (this._isDirty) {
            this._isDirty = false;
            if (this._worldBuffer.getBuffer().capacity / 4 < instanceCount * 16) {
                this._resizeBuffers(instanceCount);
            }
            this._worldBuffer.update(this._charMatrices);
            this._uvBuffer.update(this._charUvs);
        }
        if (this._useVAO) {
            if (!this._vertexArrayObject) {
                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, null, effect);
            }
            engine.bindVertexArrayObject(this._vertexArrayObject, null);
        }
        else {
            // VBOs
            engine.bindBuffers(this._vertexBuffers, null, effect);
        }
        engine.setAlphaMode(Constants.ALPHA_COMBINE);
        engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, instanceCount);
        engine.unbindInstanceAttributes();
        engine.setAlphaMode(Constants.ALPHA_DISABLE);
        if (this.ignoreDepthBuffer) {
            engine.setDepthBuffer(true);
        }
    }
    /**
     * Release associated resources
     */
    dispose() {
        if (this._worldBuffer) {
            this._worldBuffer.dispose();
            this._worldBuffer = null;
        }
        if (this._uvBuffer) {
            this._uvBuffer.dispose();
            this._uvBuffer = null;
        }
        if (this._spriteBuffer) {
            this._spriteBuffer.dispose();
            this._spriteBuffer = null;
        }
        if (this._vertexArrayObject) {
            this._engine.releaseVertexArrayObject(this._vertexArrayObject);
            this._vertexArrayObject = null;
        }
    }
    /**
     * Creates a new TextRenderer instance asynchronously
     * @param font define the font asset to use
     * @param engine define the engine to use
     * @returns a promise that resolves to the created TextRenderer instance
     */
    static async CreateTextRendererAsync(font, engine) {
        if (!engine.getCaps().instancedArrays || !engine._features.supportSpriteInstancing) {
            throw new Error("Instanced arrays are required for MSDF text rendering.");
        }
        let shaderLanguage = 0 /* ShaderLanguage.GLSL */;
        let vertex = "";
        let fragment = "";
        if (engine.isWebGPU) {
            shaderLanguage = 1 /* ShaderLanguage.WGSL */;
            vertex = (await import("./shadersWGSL/msdf.vertex.js")).msdfVertexShaderWGSL.shader;
            fragment = (await import("./shadersWGSL/msdf.fragment.js")).msdfPixelShaderWGSL.shader;
        }
        else {
            vertex = (await import("./shaders/msdf.vertex.js")).msdfVertexShader.shader;
            fragment = (await import("./shaders/msdf.fragment.js")).msdfPixelShader.shader;
        }
        const textRenderer = new TextRenderer(engine, shaderLanguage, font);
        textRenderer._setShaders(vertex, fragment);
        return textRenderer;
    }
}
//# sourceMappingURL=textRenderer.js.map